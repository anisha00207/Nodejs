The CommonJS and RequireJS specifications:


Both CommonJS and RequireJS are module systems used for defining how JavaScript files and modules interact with each other in a structured and modular way.

CommonJS is primarily used in Node.js for server-side JavaScript.

RequireJS is an AMD (Asynchronous Module Definition) implementation used for loading modules in the browser.

Let’s explore both specifications in the context of Node.js and provide examples for each.

1. CommonJS in Node.js

CommonJS is the module system used by Node.js. It allows you to organize your code into smaller, reusable modules that can be imported and exported.

Key Concepts:

Modules are loaded synchronously.

You use require() to import modules.
You use module.exports or exports to export modules.

Example 1: Basic CommonJS Example

Let’s create two files:

math.js: A module that exports math operations.
app.js: A file that imports the math.js module and uses it.
math.js (Exporting Module):

// Define math functions
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

// Export the functions
module.exports = {
    add,
    subtract
};

app.js (Importing Module):

// Import the math module
const math = require('./math');

// Use the imported functions
console.log("Addition:", math.add(5, 3)); // Outputs: 8
console.log("Subtraction:", math.subtract(5, 3)); // Outputs: 2

In this example:

math.js defines two functions (add and subtract) and exports them as a module.
app.js imports the math.js module using require() and calls the exported functions.

Example 2: Exporting Multiple Values with exports
In CommonJS, you can use exports as a shorthand for exporting multiple things.

math.js (Using exports):

// Define functions
exports.add = function (a, b) {
    return a + b;
};

exports.subtract = function (a, b) {
    return a - b;
};

app.js (Importing):

const math = require('./math');
console.log(math.add(10, 20)); // Outputs: 30
console.log(math.subtract(20, 10)); // Outputs: 10

Here, exports is a shorthand for module.exports, and both work the same way.

2. RequireJS (AMD)

RequireJS is a JavaScript file and module loader used in browsers. It is based on the AMD (Asynchronous Module Definition) specification, which allows modules to be loaded asynchronously.

Key Concepts:

Modules are loaded asynchronously.
You define modules using define().
You load modules using require().


Defining modules with exports:


Defining modules in Node.js is a fundamental aspect that helps in organizing and managing code. In Node.js, modules are encapsulated blocks of code that can be exported and reused in different parts of an application. Here’s how to define modules using the exports and module.exports objects.

1. Basic Module Definition
You can create a simple module by defining a function and exporting it.

Example: simpleFunction.js

// Define a simple function
function greet(name) {
    return `Hello, ${name}!`;
}

// Export the function

module.exports = greet;

Using the Module

// Import the module
const greet = require('./simpleFunction');

// Use the function
console.log(greet('Alice')); // Output: Hello, Alice!

2. Exporting Multiple Functions

You can export multiple functions using exports.

Example: mathOperations.js

// Define functions
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

// Export multiple functions

exports.add = add;
exports.subtract = subtract;

Using the Module

// Import the module
const math = require('./mathOperations');

// Use the functions
console.log(math.add(5, 3));      // Output: 8
console.log(math.subtract(5, 3)); // Output: 2

3. Exporting an Object

You can export an object that contains multiple properties and methods.

Example: user.js

// Define a user object
const user = {
    name: 'John',
    age: 30,
    greet: function() {
        return `Hello, my name is ${this.name}.`;
    }
};

// Export the user object
module.exports = user;

Using the Module

// Import the module
const user = require('./user');

// Access properties and methods
console.log(user.name);            // Output: John
console.log(user.greet());         // Output: Hello, my name is John.

4. Using module.exports for Different Exports

You can overwrite module.exports to export a single item.

Example: config.js

// Define a configuration object
const config = {
    host: 'localhost',
    port: 8080
};

// Overwrite module.exports
module.exports = config;

Using the Module

// Import the module
const config = require('./config');

// Access the config
console.log(config.host); // Output: localhost
console.log(config.port); // Output: 8080

5. Combining exports and module.exports

You can use both exports and module.exports, but be careful with overwriting.

Example: combined.js

// Define a function
function sayHi() {
    return 'Hi!';
}

// Add to exports
exports.sayHi = sayHi;

// Overwrite module.exports with an object
module.exports = {
    message: 'Welcome!',
    status: 'Active'
};

Using the Module

// Import the module
const combined = require('./combined');

// Access properties
console.log(combined.message); // Output: Welcome!
console.log(combined.status);  // Output: Active
// console.log(combined.sayHi()); // This will be undefined


Modules are singletons:


In Node.js, modules are singletons, meaning that a module is loaded only once, and any subsequent require calls return the same instance of that module. This design is fundamental to Node.js, allowing you to maintain a single state and share data between different parts of your application without needing to pass references explicitly.

Key Concepts
Module Loading: When a module is first loaded, Node.js caches the module's exports. Any subsequent calls to require for that module will return the cached version.

Singleton Behavior: Since the same instance is used throughout the application, any changes made to the module's state will be reflected everywhere the module is imported.

Basic Example

Creating a Singleton Module

// counter.js
let count = 0;

const increment = () => {
    count += 1;
    return count;
};

const getCount = () => {
    return count;
};

module.exports = {
    increment,
    getCount,
};
Using the Singleton Module

// app1.js

const counter = require('./counter');

console.log(counter.increment()); // Output: 1
console.log(counter.increment()); // Output: 2

// app2.js

const counter = require('./counter');

console.log(counter.getCount()); // Output: 2 (reflects the state from app1.js)

Example with State

In the above example, both app1.js and app2.js access the same counter module, and changes made in one file are visible in the other.

Example with Classes

You can also create a singleton using a class:

// db.js
class Database {
    constructor() {
        if (!Database.instance) {
            this.connection = this.connect();
            Database.instance = this;
        }
        return Database.instance;
    }

    connect() {
        console.log('Connecting to the database...');
        return {}; // Simulate a database connection
    }
}

const instance = new Database();
Object.freeze(instance); // Optional: Prevent modification of the instance

module.exports = instance;

Using the Database Singleton

// app1.js

const db1 = require('./db');
console.log(db1.connection); // Output: {} (simulated connection)

// app2.js

const db2 = require('./db');
console.log(db2.connection); // Output: {} (same instance as db1)

Example with Configuration

Modules can also be used to manage configurations as singletons:

// config.js
const config = {
    apiEndpoint: 'https://api.example.com',
    apiKey: '12345',
};

module.exports = config;

Using the Configuration Module

// app1.js
const config = require('./config');
console.log(config.apiEndpoint); // Output: 'https://api.example.com'

// app2.js
const config = require('./config');
config.apiEndpoint = 'https://api.newurl.com'; // Modifying the config

console.log(config.apiEndpoint); // Output: 'https://api.newurl.com'

Summary

Node.js modules are singletons, allowing shared state across different parts of your application.
Changes to a module's state are reflected globally due to the caching mechanism.
You can implement singletons using plain objects, classes, or configuration modules, depending on your needs.


Creating a package:

Creating a package in Node.js involves setting up a new directory, initializing it with npm, and adding the necessary files. Here’s a step-by-step guide with examples.

Step 1: Setting Up Your Directory
Create a New Directory

mkdir my-package
cd my-package
Initialize npm This creates a package.json file.

npm init -y

Step 2: Structure Your Package

Here’s a basic structure:

my-package/
├── package.json
├── index.js
└── lib/
    └── myModule.js

Step 3: Write Your Code

Example 1: Basic Functionality

Create index.js This file will serve as the main entry point for your package.

const myModule = require('./lib/myModule');

module.exports = {
    myFunction: myModule.myFunction,
};

Create lib/myModule.js This file contains the actual functionality.

// lib/myModule.js
function myFunction() {
    return "Hello from my package!";
}

module.exports = {
    myFunction,
};

Step 4: Testing Your Package

You can create a simple test file to check if your package works as expected.

Create test.js

const { myFunction } = require('./index');

console.log(myFunction()); // Output: Hello from my package!

Run the Test

node test.js

Step 5: Adding More Features

Example 2: Asynchronous Functionality

You can also add more complex features. Here’s an example of an asynchronous function.

Update lib/myModule.js

function myAsyncFunction() {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve("Hello from async function!");
        }, 1000);
    });
}

module.exports = {
    myFunction,
    myAsyncFunction,
};

Update index.js

const myModule = require('./lib/myModule');

module.exports = {
    myFunction: myModule.myFunction,
    myAsyncFunction: myModule.myAsyncFunction,
};

Update test.js to Test Asynchronous Function

const { myFunction, myAsyncFunction } = require('./index');

console.log(myFunction()); // Output: Hello from my package!

myAsyncFunction().then(console.log); // Output: Hello from async function!

Step 6: Publishing Your Package

Login to npm If you haven’t logged in yet, use:

npm login

Publish Your Package Make sure your package name is unique in the npm registry.

npm publish

Step 7: Example Packages

You can create various types of packages depending on your needs:

Utility Libraries: Functions for common tasks (e.g., formatting dates).
Middleware: Functions that process requests in Express apps.
CLI Tools: Command-line tools that automate tasks.


Module scope and construction:


Node.js uses a module system to encapsulate code, making it reusable and maintainable. Each module in Node.js is treated as an isolated piece of code with its own scope, preventing conflicts with other modules.

Key Concepts
Module: A module is a JavaScript file that contains code to be reused. Each file in Node.js is a module by default.

Module Scope: Each module has its own scope, which means variables and functions declared within a module are not accessible from outside unless explicitly exported.

Exporting and Importing:

Use module.exports to expose functions, objects, or variables from a module.
Use require() to import them in another module.
Example 1: Basic Module Creation
Creating a Module (math.js)

// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

module.exports = {
    add,
    subtract
};

Using the Module (app.js)

// app.js
const math = require('./math');

console.log(math.add(5, 3));      // Output: 8
console.log(math.subtract(5, 3)); // Output: 2

Example 2: Encapsulation

Modules can encapsulate private variables and expose only necessary parts.

Creating a Module with Private Variables (counter.js)

// counter.js
let count = 0;

const increment = () => {
    count++;
    return count;
};

const decrement = () => {
    count--;
    return count;
};

module.exports = {
    increment,
    decrement
};

Using the Counter Module (app.js)

// app.js
const counter = require('./counter');

console.log(counter.increment()); // Output: 1
console.log(counter.increment()); // Output: 2
console.log(counter.decrement()); // Output: 1
// Note: `count` is private and cannot be accessed directly.

Example 3: Using Class in a Module

You can also export classes from a module.

Creating a Class Module (Person.js)

// Person.js
class Person {
    constructor(name) {
        this.name = name;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

module.exports = Person;
Using the Class Module (app.js)

// app.js
const Person = require('./Person');

const alice = new Person('Alice');
alice.greet(); // Output: Hello, my name is Alice

Example 4: Asynchronous Module

Modules can also be asynchronous.

Creating an Asynchronous Module (dataFetcher.js)

// dataFetcher.js
const fetchData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve('Data fetched!');
        }, 1000);
    });
};

module.exports = fetchData;

Using the Asynchronous Module (app.js)

// app.js
const fetchData = require('./dataFetcher');

fetchData().then((data) => {
    console.log(data); // Output: Data fetched!
});

Summary
Each Node.js module has its own scope, helping avoid global namespace pollution.
Use module.exports to export parts of a module and require() to import them.
Modules can encapsulate private data and expose only what is necessary.
Classes and asynchronous functions can also be used within modules.

Module caching:


Module caching in Node.js is a fundamental feature that enhances the performance and efficiency of applications. When you require a module in Node.js, it caches the module's exports the first time it is loaded. Subsequent calls to require the same module will return the cached version instead of loading it again. This behavior minimizes the overhead of re-loading modules and helps in managing memory more effectively.

How Module Caching Works

Loading the Module: When you use require(), Node.js looks for the module in the node_modules directory or in the paths defined in the NODE_PATH environment variable.

Caching the Exports: The first time the module is loaded, Node.js executes the code and caches the exports object in require.cache.

Subsequent Requires: If you require the same module again, Node.js returns the cached exports rather than executing the module's code again.

Example 1: Basic Module Caching

moduleA.js

let counter = 0;

function increment() {
  counter++;
  console.log(`Counter: ${counter}`);
}

module.exports = {
  increment,
};

app.js

const moduleA = require('./moduleA');

moduleA.increment(); // Output: Counter: 1
moduleA.increment(); // Output: Counter: 2

// Requiring the module again

const moduleB = require('./moduleA');
moduleB.increment(); // Output: Counter: 3 (still the same instance)

Example 2: Modifying Cached Modules

If you modify the exported object in one part of your application, the changes will be reflected across all references to that module.

moduleA.js

let counter = 0;

function increment() {
  counter++;
  console.log(`Counter: ${counter}`);
}

module.exports = {
  increment,
  counter,
};

app.js

const moduleA = require('./moduleA');

moduleA.increment(); // Output: Counter: 1

// Modifying the cached module's state
moduleA.counter = 5;

const moduleB = require('./moduleA');
console.log(moduleB.counter); // Output: 5 (modification is reflected)

Example 3: Clearing the Cache
In certain situations, you might want to clear the cache to force Node.js to load the module again.

app.js

const moduleA = require('./moduleA');

moduleA.increment(); // Output: Counter: 1

// Clear the cache
delete require.cache[require.resolve('./moduleA')];

// Require the module again

const newModuleA = require('./moduleA');
newModuleA.increment(); // Output: Counter: 1 (new instance)

Example 4: Singleton Pattern

Module caching is often used to implement a singleton pattern where only one instance of a module is created.

singleton.js

let instance;

class Singleton {
  constructor() {
    if (!instance) {
      instance = this;
    }
    return instance;
  }
}

module.exports = new Singleton();

app.js

const singletonA = require('./singleton');
const singletonB = require('./singleton');

console.log(singletonA === singletonB); // Output: true (same instance)

Summary
Module caching in Node.js significantly improves performance by preventing unnecessary re-execution of module code. Understanding this feature helps in managing state and memory effectively, especially when designing larger applications. Use module caching wisely to create efficient, modular applications.


Global Modules:


Global modules in Node.js are packages that are available throughout your system and can be accessed from any file in your Node.js applications without needing to specify a local installation. They are usually installed globally using the Node Package Manager (npm) with the -g flag.

Key Points about Global Modules

Installation: To install a global module, you use:

npm install -g <module-name>

Location: Global modules are stored in a directory specific to your system, which is often different based on your operating system.

Use Case: Global modules are generally used for command-line tools and utilities that you might need to run from anywhere.

Examples of Global Modules

1. Express Generator

The Express Generator is a tool to scaffold an Express application quickly.

Installation:

npm install -g express-generator

Usage: After installing, you can create a new Express app:

express myapp
cd myapp
npm install

This command creates a new directory myapp with the boilerplate for an Express application.

2. Nodemon

Nodemon is a utility that automatically restarts your Node.js application when file changes in the directory are detected.

Installation:

npm install -g nodemon

Usage: You can run your application with nodemon instead of node:

nodemon app.js

This will watch for any changes in app.js and automatically restart the server, making development easier.

3. Typescript

TypeScript is a superset of JavaScript that compiles to plain JavaScript.

Installation:

npm install -g typescript

Usage: You can compile TypeScript files using the tsc command:

tsc myfile.ts

This will create a myfile.js that can be run with Node.js.

4. Gulp

Gulp is a toolkit for automating time-consuming tasks in your development workflow.

Installation:

npm install -g gulp-cli

Usage: Once installed, you can create a gulpfile.js and run:

gulp

Gulp will execute tasks defined in your gulpfile.js.



Different types of Examples on Arrow Functions in Node JS:


1. Basic Syntax

Arrow functions provide a concise way to write function expressions. They are defined using the => syntax.

Example: Basic Arrow Function

const add = (a, b) => a + b;
console.log(add(2, 3)); // Output: 5

2. Returning Objects

To return an object from an arrow function, wrap the object in parentheses.

Example: Returning an Object

const createUser = (name, age) => ({ name, age });
console.log(createUser('Alice', 30)); // Output: { name: 'Alice', age: 30 }

3. No Parameters

If there are no parameters, use empty parentheses.

Example: No Parameters

const greet = () => 'Hello, World!';
console.log(greet()); // Output: Hello, World!

4. Single Parameter

You can omit the parentheses for a single parameter.

Example: Single Parameter

const square = x => x * x;
console.log(square(4)); // Output: 16

5. Multiple Statements

If the function body has multiple statements, wrap them in curly braces and use the return statement.

Example: Multiple Statements

const multiplyAndLog = (x, y) => {
    const result = x * y;
    console.log(result);
    return result;
};
multiplyAndLog(3, 5); // Output: 15

6. Lexical this

Arrow functions do not have their own this context. They inherit this from the surrounding scope.

Example: Lexical this

function Counter() {
    this.count = 0;

    setInterval(() => {
        this.count++;
        console.log(this.count);
    }, 1000);
}

const counter = new Counter();
// This will log the count every second.

7. Using with Array Methods

Arrow functions work great with array methods like map, filter, and reduce.

Example: Array Methods

const numbers = [1, 2, 3, 4, 5];

// Using map
const doubled = numbers.map(num => num * 2);
console.log(doubled); // Output: [2, 4, 6, 8, 10]

// Using filter
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // Output: [2, 4]

// Using reduce
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // Output: 15

8. Arrow Functions with Promises
You can use arrow functions with Promises for cleaner syntax.

Example: Promises

javascript
Copy code
const fetchData = () => new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('Data received!');
    }, 1000);
});

fetchData()
    .then(data => console.log(data)) // Output: Data received!
    .catch(error => console.error(error));

9. Using Arrow Functions in Class Methods
Arrow functions can be used in class methods to ensure this is bound correctly.

Example: Class Method

javascript
Copy code
class User {
    constructor(name) {
        this.name = name;
    }

    greet = () => {
        console.log(`Hello, ${this.name}!`);
    }
}

const user = new User('Bob');
user.greet(); // Output: Hello, Bob!

10. Arrow Functions as Callback Functions
They can be used as callbacks, maintaining the context of this.

Example: Callback Functions

javascript
Copy code
const button = document.createElement('button');
button.textContent = 'Click me';

button.addEventListener('click', () => {
    console.log('Button clicked!');
});

document.body.appendChild(button);



Examples on Object Literals:


1. Basic Object Literal
javascript
Copy code
const person = {
  name: 'Alice',
  age: 30,
  greet: function() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

person.greet(); // Output: Hello, my name is Alice

2. Object Literal with Dynamic Properties

javascript
Copy code
const key = 'age';
const user = {
  name: 'Bob',
  [key]: 25
};

console.log(user); // Output: { name: 'Bob', age: 25 }

3. Nested Object Literals
javascript
Copy code
const company = {
  name: 'TechCorp',
  location: 'New York',
  employees: {
    developer: {
      name: 'Charlie',
      age: 28
    },
    designer: {
      name: 'Diana',
      age: 26
    }
  }
};

console.log(company.employees.developer.name); // Output: Charlie
4. Object Literal Methods
javascript
Copy code
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3)); // Output: 8
console.log(calculator.subtract(5, 3)); // Output: 2

5. Object Literal with Getter and Setter

const user = {
  firstName: 'John',
  lastName: 'Doe',
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(name) {
    const parts = name.split(' ');
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
};

console.log(user.fullName); // Output: John Doe
user.fullName = 'Jane Smith';
console.log(user.firstName); // Output: Jane

6. Object Literal with Spread Syntax

javascript
Copy code
const person1 = {
  name: 'Eve',
  age: 29
};

const person2 = {
  ...person1,
  location: 'London'
};

console.log(person2); // Output: { name: 'Eve', age: 29, location: 'London' }

7. Object Literal for Configuration

javascript
Copy code
const config = {
  host: 'localhost',
  port: 3000,
  db: {
    user: 'admin',
    password: 'secret'
  }
};

console.log(`Server running at http://${config.host}:${config.port}`);

8. Using Object Literal with Object.assign

const defaults = {
  host: 'localhost',
  port: 3000
};

const options = {
  port: 8080
};

const config = Object.assign({}, defaults, options);
console.log(config); // Output: { host: 'localhost', port: 8080 }

9. Using Object Literal in Constructor Function

function Car(make, model) {
  this.make = make;
  this.model = model;
  this.details = function() {
    return `${this.make} ${this.model}`;
  };
}

const car1 = new Car('Toyota', 'Corolla');

console.log(car1.details()); // Output: Toyota Corolla

10. Object Literal in Async Function

const fetchData = async () => {
  const data = {
    id: 1,
    title: 'Sample Post'
  };
  return data;
};

fetchData().then(result => {
  console.log(result); // Output: { id: 1, title: 'Sample Post' }
});



Examples on Destructuring:


1. Array Destructuring

Array destructuring allows you to unpack values from arrays into distinct variables.

Example 1: Basic Array Destructuring

const fruits = ['apple', 'banana', 'orange'];
const [first, second, third] = fruits;

console.log(first); // 'apple'
console.log(second); // 'banana'
console.log(third); // 'orange'

Example 2: Skipping Elements

const colors = ['red', 'green', 'blue'];
const [primary, , secondary] = colors;

console.log(primary); // 'red'
console.log(secondary); // 'blue'

Example 3: Default Values
javascript
Copy code
const numbers = [1];
const [a, b = 2] = numbers;

console.log(a); // 1
console.log(b); // 2

2. Object Destructuring

Object destructuring allows you to unpack properties from objects into distinct variables.

Example 1: Basic Object Destructuring
javascript
Copy code
const person = {
    name: 'Alice',
    age: 30,
    city: 'New York'
};

const { name, age } = person;

console.log(name); // 'Alice'
console.log(age); // 30

Example 2: Renaming Variables
javascript
Copy code
const user = {
    username: 'john_doe',
    password: 'secret'
};

const { username: userName, password: userPassword } = user;

console.log(userName); // 'john_doe'
console.log(userPassword); // 'secret'

Example 3: Default Values

const settings = {
    volume: 70
};

const { volume, brightness = 50 } = settings;

console.log(volume); // 70
console.log(brightness); // 50

3. Nested Destructuring

You can also destructure nested objects or arrays.

Example 1: Nested Objects

const student = {
    name: 'Bob',
    subjects: {
        math: 90,
        science: 85
    }
};

const { name, subjects: { math, science } } = student;

console.log(name); // 'Bob'
console.log(math); // 90
console.log(science); // 85

Example 2: Nested Arrays

const scores = [[95, 85], [75, 80]];
const [[mathScore, scienceScore], [englishScore, historyScore]] = scores;

console.log(mathScore); // 95
console.log(scienceScore); // 85

4. Function Parameter Destructuring

You can use destructuring in function parameters to extract values directly.

Example 1: Object Parameter Destructuring

function displayUser({ name, age }) {
    console.log(`Name: ${name}, Age: ${age}`);
}

const userInfo = { name: 'Eve', age: 28 };
displayUser(userInfo); // 'Name: Eve, Age: 28'

Example 2: Array Parameter Destructuring

function calculate([a, b]) {
    return a + b;
}

const numbers = [5, 10];
console.log(calculate(numbers)); // 15

5. Destructuring with Default Values in Functions

You can provide default values while destructuring in function parameters.

function createProfile({ name, age = 18 } = {}) {
    console.log(`Name: ${name}, Age: ${age}`);
}

createProfile({ name: 'Tom' }); // 'Name: Tom, Age: 18'
createProfile(); // 'Name: undefined, Age: 18'


Examples on Closures:


1. Basic Closure Example

A simple example to demonstrate how closures work.


function outerFunction() {
    let outerVariable = "I'm from the outer function!";

    return function innerFunction() {
        console.log(outerVariable);
    };
}

const innerFunc = outerFunction();
innerFunc(); // Output: I'm from the outer function!

2. Closure with Counter

Using closures to create a private counter.

function createCounter() {
    let count = 0;

    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // Output: 1
console.log(counter.increment()); // Output: 2
console.log(counter.getCount()); // Output: 2
console.log(counter.decrement()); // Output: 1

3. Closure with Arguments

Closures can capture variables from the parent scope, even when passed as arguments.

function multiplier(factor) {
    return function(x) {
        return x * factor;
    };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5)); // Output: 10
console.log(triple(5)); // Output: 15

4. Closure for Data Privacy

Using closures to create private variables.

function createPerson(name) {
    let age = 0; // Private variable

    return {
        getName: function() {
            return name;
        },
        getAge: function() {
            return age;
        },
        setAge: function(newAge) {
            age = newAge;
        }
    };
}

const person = createPerson('Alice');
console.log(person.getName()); // Output: Alice
console.log(person.getAge()); // Output: 0
person.setAge(30);
console.log(person.getAge()); // Output: 30

5. Closure in Asynchronous Programming

Demonstrating closures with asynchronous callbacks.

function delayedGreeting(name) {
    setTimeout(function() {
        console.log(`Hello, ${name}!`);
    }, 1000);
}

delayedGreeting('Bob'); // After 1 second: Hello, Bob!

6. Using Closures in a Loop

A common mistake is using closures in loops; here's how to do it correctly.

function createFunctions() {
    let funcs = [];

    for (let i = 0; i < 3; i++) {
        funcs.push(function() {
            console.log(i);
        });
    }

    return funcs;
}

const functions = createFunctions();
functions[0](); // Output: 3
functions[1](); // Output: 3
functions[2](); // Output: 3

7. Advanced Closure Example

Using closures for memoization.

function memoize(fn) {
    const cache = {};

    return function(x) {
        if (cache[x]) {
            return cache[x];
        }
        const result = fn(x);
        cache[x] = result;
        return result;
    };
}

const fibonacci = memoize(function(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(10)); // Output: 55

8. Closure for Partial Application

Using closures to create a function that partially applies arguments.

function add(a) {
    return function(b) {
        return a + b;
    };
}

const addFive = add(5);
console.log(addFive(10)); // Output: 15


Named imports and default imports:

1. Default Exports and Imports
Default Export allows you to export a single value from a module. When importing, you can choose any name for the imported value.

Example:

a. Create a file named math.js:

// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

export default { add, subtract };

b. Create a file named app.js:

// app.js
import math from './math.js';

const sum = math.add(5, 3);
const difference = math.subtract(5, 3);

console.log(`Sum: ${sum}, Difference: ${difference}`);
2. Named Exports and Imports
Named Export allows you to export multiple values from a module. When importing, you must use the same names as those exported.

Example:

a. Create a file named mathNamed.js:

// mathNamed.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

b. Create a file named appNamed.js:

// appNamed.js
import { add, subtract } from './mathNamed.js';

const sum = add(5, 3);
const difference = subtract(5, 3);

console.log(`Sum: ${sum}, Difference: ${difference}`);

3. Combining Default and Named Exports
You can combine both default and named exports in the same module.

Example:

a. Create a file named mathCombined.js:

// mathCombined.js
export const multiply = (a, b) => a * b;
export const divide = (a, b) => a / b;

const add = (a, b) => a + b;

export default { add, multiply, divide };

b. Create a file named appCombined.js:

// appCombined.js
import math, { multiply, divide } from './mathCombined.js';

const sum = math.add(10, 5);
const product = multiply(10, 5);
const quotient = divide(10, 5);

console.log(`Sum: ${sum}, Product: ${product}, Quotient: ${quotient}`);

4. Renaming Imports

You can also rename imports when importing named exports to avoid naming conflicts.

Example:

a. Create a file named mathRename.js:

// mathRename.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

b. Create a file named appRename.js:

// appRename.js
import { add as sum, subtract as diff } from './mathRename.js';

const total = sum(10, 5);
const difference = diff(10, 5);

console.log(`Total: ${total}, Difference: ${difference}`);
Summary
Default Imports: Import a single value and name it as desired.
Named Imports: Import specific values using their exact names.
Combining Exports: Mix default and named exports in the same module.
Renaming Imports: Rename imported values to avoid conflicts.


Examples on Async Await:


1. Basic Async Function

Program: Basic Async Function

// Basic async function example
const fetchData = async () => {
    return "Data fetched successfully!";
};

const main = async () => {
    const data = await fetchData();
    console.log(data);
};

main();

2. Async Function with Try/Catch

Program: Error Handling in Async Function

const fetchDataWithError = async () => {
    throw new Error("Failed to fetch data!");
};

const main = async () => {
    try {
        const data = await fetchDataWithError();
        console.log(data);
    } catch (error) {
        console.error(error.message);
    }
};

main();

3. Fetching Data from an API

Program: Fetching Data from a Public API

const axios = require('axios');

const fetchUserData = async () => {
    const response = await axios.get('https://jsonplaceholder.typicode.com/users/1');
    return response.data;
};

const main = async () => {
    try {
        const user = await fetchUserData();
        console.log(user);
    } catch (error) {
        console.error(error.message);
    }
};

main();

4. Parallel Async Calls

Program: Making Multiple Async Calls in Parallel

const fetchPost = async (id) => {
    const response = await axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`);
    return response.data;
};

const main = async () => {
    try {
        const posts = await Promise.all([fetchPost(1), fetchPost(2), fetchPost(3)]);
        console.log(posts);
    } catch (error) {
        console.error(error.message);
    }
};

main();

5. Sequential Async Calls

Program: Making Async Calls Sequentially

const fetchPost = async (id) => {
    const response = await axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`);
    return response.data;
};

const main = async () => {
    try {
        const post1 = await fetchPost(1);
        console.log(post1);
        const post2 = await fetchPost(2);
        console.log(post2);
        const post3 = await fetchPost(3);
        console.log(post3);
    } catch (error) {
        console.error(error.message);
    }
};

main();

6. Async Function with Database Call (Using MongoDB)
Program: Async Function to Retrieve Data from MongoDB

const { MongoClient } = require('mongodb');

const url = 'mongodb://localhost:27017';
const dbName = 'testDB';

const fetchUsers = async () => {
    const client = new MongoClient(url);
    try {
        await client.connect();
        const db = client.db(dbName);
        const users = await db.collection('users').find().toArray();
        return users;
    } finally {
        await client.close();
    }
};

const main = async () => {
    try {
        const users = await fetchUsers();
        console.log(users);
    } catch (error) {
        console.error(error.message);
    }
};

main();

7. Async Function with Custom Delay

Program: Simulating Delays with Async/Await

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const fetchDataWithDelay = async () => {
    console.log("Fetching data...");
    await delay(2000); // 2 seconds delay
    return "Data fetched after delay!";
};

const main = async () => {
    const data = await fetchDataWithDelay();
    console.log(data);
};

main();

8. Combining Async/Await with Events

Program: Async Function with EventEmitter

const EventEmitter = require('events');
const emitter = new EventEmitter();

const asyncOperation = async () => {
    return new Promise((resolve) => {
        emitter.on('done', resolve);
        setTimeout(() => {
            console.log("Operation complete!");
            emitter.emit('done');
        }, 1000);
    });
};

const main = async () => {
    await asyncOperation();
    console.log("Async operation finished.");
};

main();


The require keyword:


The require keyword in Node.js is used to import modules, JSON files, and local files into your application. Here’s a structured overview of various types of programs that demonstrate the use of require.

1. Importing Built-in Modules
Example: Using the fs Module

// fsExample.js
const fs = require('fs');

// Read a file asynchronously
fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(data);
});
2. Importing Local Modules
Example: Creating and Using a Custom Module

Step 1: Create a module

// mathOperations.js
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

module.exports = { add, subtract };
Step 2: Use the custom module

// app.js
const math = require('./mathOperations');

console.log(math.add(5, 3)); // Output: 8
console.log(math.subtract(5, 3)); // Output: 2

3. Importing JSON Files

Example: Using a JSON File

Step 1: Create a JSON file

// data.json
{
    "name": "John",
    "age": 30
}
Step 2: Require the JSON file

// jsonExample.js
const data = require('./data.json');

console.log(data.name); // Output: John
console.log(data.age); // Output: 30

4. Importing Node Packages
Example: Using an External Package

// Install the lodash package first using: npm install lodash
const _ = require('lodash');

// Using lodash to find the maximum number
const numbers = [1, 2, 3, 4, 5];
const maxNumber = _.max(numbers);
console.log(maxNumber); // Output: 5

5. Importing with Aliases

Example: Renaming a Required Module

// app.js
const fs = require('fs');

// Using the fs module
fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) throw err;
    console.log(data);
});

6. Requiring Multiple Modules
Example: Using Multiple Modules in One File

// app.js
const fs = require('fs');
const path = require('path');

const filePath = path.join(__dirname, 'example.txt');

fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) throw err;
    console.log(data);
});

7. Circular Dependencies

Example: Handling Circular Dependencies

// moduleA.js
const moduleB = require('./moduleB');

function greet() {
    console.log("Hello from Module A!");
    moduleB.respond();
}

module.exports = { greet };

// moduleB.js
const moduleA = require('./moduleA');

function respond() {
    console.log("Response from Module B!");
}

module.exports = { respond };

// app.js
const moduleA = require('./moduleA');

moduleA.greet();


Exception handling:

• Error handling using try catch:


In Node.js, error handling is essential for writing reliable, robust applications. The most common method for error handling is using try...catch blocks. They allow you to catch exceptions that may be thrown during the execution of code and handle them gracefully.

Here's how try...catch works in Node.js:

try block: This block contains the code that may throw an exception.
catch block: This block is executed if an error occurs in the try block.
finally block (optional): This block executes regardless of whether an exception was thrown or not.

Basic Syntax:

try {
  // Code that may throw an error
} catch (error) {
  // Code to handle the error
} finally {
  // Code that will always execute (optional)
}

Example 1: Basic Error Handling

Let's start with a basic example to demonstrate how to handle errors in Node.js using try...catch.

try {
  let result = 10 / 0; // No error, this will work fine
  console.log(result);
} catch (error) {
  console.error("Error occurred:", error.message);
}
Explanation:

Here, 10 / 0 doesn't cause an error in JavaScript, but this demonstrates how the code inside the try block works without throwing an exception.
If there were any error, it would be caught by the catch block, and the error message would be printed.

Example 2: Handling Synchronous Errors

Let's see how to catch a synchronous error:

try {
  let obj = JSON.parse("invalidJSON"); // This will throw a syntax error
} catch (error) {
  console.error("Error occurred while parsing JSON:", error.message);
}
Explanation:

Parsing an invalid JSON string causes a SyntaxError to be thrown.
The error is caught by the catch block and handled.

Example 3: Handling Errors with a finally Block

The finally block executes whether an error occurs or not. It is useful for cleanup activities.

try {
  let data = fs.readFileSync("somefile.txt"); // Assume the file doesn't exist
} catch (error) {
  console.error("File read error:", error.message);
} finally {
  console.log("Finished trying to read the file.");
}
Explanation:

If the file does not exist, an error will be thrown in the try block, and the error will be caught and logged in the catch block.
The finally block will run whether or not the error occurs.

Example 4: Catching Errors in Functions
You can wrap function calls in try...catch to handle any exceptions they throw:

function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero"); // Custom Error 
  }
  return a / b;
}

try {
  console.log(divide(4, 0));
} catch (error) {
  console.error("Error:", error.message);
}
Explanation:

If the divide function detects an invalid operation (division by zero), it throws an error.
The try...catch block catches that error and handles it.

Example 5: Error Handling in Asynchronous Code

In Node.js, most operations are asynchronous. The try...catch mechanism does not catch asynchronous errors directly. Here's an example of how to handle asynchronous errors using promises.

Asynchronous Example using Promises

const fs = require("fs").promises;

async function readFile() {
  try {
    let data = await fs.readFile("nonexistent.txt", "utf-8");
    console.log(data);
  } catch (error) {
    console.error("Error reading file:", error.message);
  }
}

readFile();
Explanation:

We use async/await to handle asynchronous code.
If the file doesn't exist, the fs.readFile will reject the promise, and the error will be caught in the catch block.

Asynchronous Example using .catch() in Promises

const fs = require("fs").promises;

fs.readFile("nonexistent.txt", "utf-8")
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error("Error reading file:", error.message);
  });
Explanation:

Here, instead of try...catch, we handle the error using the .catch() method directly on the promise.

Example 6: Custom Errors

You can throw custom errors to handle specific scenarios in your application.

class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = "CustomError";
  }
}

try {
  throw new CustomError("Something went wrong!");
} catch (error) {
  console.error(`${error.name}: ${error.message}`);
}
Explanation:

This shows how to create a custom error by extending the Error class.
The error is thrown, and caught, with the name and message being printed.
Best Practices for Error Handling
Use try...catch judiciously: Wrap only the code that can reasonably fail, and not too much logic.
Avoid using try...catch for control flow: It’s better to handle logic through if-else conditions rather than relying on exceptions.
Always log meaningful error messages: Include details about the context where the error happened.
Handle asynchronous errors with .catch() or async/await: Synchronous try...catch does not work with asynchronous code unless used with await.

Example 7: Graceful Shutdown

In production, error handling is crucial for ensuring that the system continues to function correctly or shuts down gracefully.

process.on("uncaughtException", (error) => {
  console.error("Uncaught Exception:", error);
  // Optionally, perform cleanup and shutdown the process
  process.exit(1);
});

try {
  nonExistentFunction(); // This will throw an uncaught exception
} catch (error) {
  console.error("Error caught:", error.message);
}
Explanation:

We handle any uncaught exceptions using process.on("uncaughtException") to log errors or shut down the process.


• Error Object:

In Node.js, the Error object is used to represent and handle errors. It's a built-in object in JavaScript and is extended by Node.js to provide more specialized error handling capabilities.

1. Basic Error Object
The Error object can be instantiated with a message string to describe the error.

Example:

const error = new Error("Something went wrong!");
console.log(error.message);  // Outputs: Something went wrong!
console.log(error.name);     // Outputs: Error
console.log(error.stack);    // Outputs: Stack trace of where the error occurred

Key properties of the Error object:

message: A human-readable description of the error.
name: The type of error (default is Error).
stack: A string that shows where the error occurred in the code.

2. Throwing an Error

In JavaScript (and Node.js), you can "throw" an error using the throw keyword. This halts the execution of the program unless it's handled.

Example:

function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero is not allowed.");
  }
  return a / b;
}

try {
  console.log(divide(4, 0));
} catch (error) {
  console.error(error.message);  // Outputs: Division by zero is not allowed.
}

3. Custom Error Classes
In Node.js, you can extend the base Error class to create custom error types. This is useful when you want to define more specific error types in your application.

Example:

class ValidationError extends Error {
  constructor(message) {
    super(message); // Call the parent constructor with the message
    this.name = "ValidationError"; // Set the error name
  }
}

function validateAge(age) {
  if (age < 18) {
    throw new ValidationError("Age must be at least 18.");
  }
  return true;
}

try {
  validateAge(15);
} catch (error) {
  console.error(error.name);    // Outputs: ValidationError
  console.error(error.message); // Outputs: Age must be at least 18.
}

4. Built-in Error Types in Node.js

Node.js has several built-in error types that extend the Error object, each representing different types of errors:

TypeError: Indicates a value is not of the expected type.
RangeError: Indicates a value is not within an acceptable range.
ReferenceError: Indicates that an invalid reference is being made (e.g., referencing an undefined variable).
SyntaxError: Indicates a syntax error in the code.
EvalError: Related to the eval() function.

Example:

try {
  JSON.parse("{ invalid json }"); // SyntaxError
} catch (error) {
  console.log(error.name);    // Outputs: SyntaxError
  console.log(error.message); // Outputs: Unexpected token i in JSON at position 2
}

5. Error Handling in Asynchronous Code

In Node.js, many APIs are asynchronous. Errors in asynchronous code are typically passed to a callback as the first argument or can be caught using promises.

Example with Callbacks:

const fs = require('fs');

fs.readFile('nonexistentfile.txt', (err, data) => {
  if (err) {
    console.error(err.message);  // Outputs: ENOENT: no such file or directory, open 'nonexistentfile.txt'
  } else {
    console.log(data);
  }
});

Example with Promises:


const fsPromises = require('fs').promises;

fsPromises.readFile('nonexistentfile.txt')
  .then(data => console.log(data))
  .catch(err => console.error(err.message));  // Outputs: ENOENT: no such file or directory, open 'nonexistentfile.txt'

6. Custom Error Handling in Express

In a Node.js web application (e.g., using Express), errors can be passed to a custom error-handling middleware.

Example:

const express = require('express');
const app = express();

app.get('/', (req, res) => {
  throw new Error("This is an error!");
});

// Error-handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something went wrong!');
next();
});

app.listen(3000, () => console.log('Server running on port 3000'));

In this example, if any route throws an error, the custom error-handling middleware catches it and sends a 500 response to the client.

7. Error Propagation with next in Express

If you want to propagate errors in Express, you can pass them to the next function.

Example:

8. Best Practices for Error Handling in Node.js

Always Handle Errors: Whether using synchronous or asynchronous code, always handle errors to avoid crashes.

Use Custom Error Types: For more meaningful and context-specific error messages.

Log Errors: Make sure errors are logged for debugging and troubleshooting purposes.

Graceful Shutdown: For critical errors, it’s good practice to shut down the app gracefully after handling ongoing requests.


Custom exception handlers:


In Node.js, custom exception handling is essential for managing errors in a way that makes your application more robust and user-friendly. Custom exception handlers allow you to catch errors and respond to them in a structured and meaningful way. This is crucial for debugging, improving user experience, and maintaining the stability of your app.

Here’s a breakdown of how to implement custom exception handlers in Node.js from scratch, with examples.

Key Concepts of Custom Exception Handling
Synchronous vs Asynchronous Errors:

Synchronous errors occur during the execution of code and can be caught using try...catch blocks.
Asynchronous errors occur outside the regular execution flow, usually when working with callbacks, promises, or async/await.

Error Object in JavaScript/Node.js:

The built-in Error object contains information about what went wrong. You can extend this class to create custom errors.

1. Basic Error Handling with try...catch (Synchronous Errors)
The simplest form of handling errors in Node.js is with try...catch for synchronous operations.

function doSomethingRisky() {
  throw new Error("Something went wrong!");
}

try {
  doSomethingRisky();
} catch (error) {
  console.error("Caught an error:", error.message);
}

Output:

Caught an error: Something went wrong!

2. Creating Custom Error Classes

You can create your own custom error class by extending the built-in Error class in JavaScript. This is useful for defining domain-specific errors.

class CustomError extends Error {
  constructor(message, statusCode) {
    super(message); // Call the parent constructor with the message
    this.statusCode = statusCode; // Custom property for status code
  }
}

// Example usage

function riskyOperation() {
  throw new CustomError("Custom error occurred!", 400);
}

try {
  riskyOperation();
} catch (error) {
  console.error(`Error: ${error.message}, Status Code: ${error.statusCode}`);
}

Output:

Error: Custom error occurred!, Status Code: 400

3. Asynchronous Error Handling with Callbacks

For asynchronous code using callbacks, error handling is typically done by passing an error as the first argument to the callback.

function asyncOperation(callback) {
  setTimeout(() => {
    callback(new Error("Async operation failed!"));
  }, 1000);
}

asyncOperation((error) => {
  if (error) {
    console.error("Caught an async error:", error.message);
  }
});

Output:


Caught an async error: Async operation failed!

4. Handling Errors in Promises

In asynchronous code using promises, you can catch errors using .catch() or try...catch in combination with async/await.

Example with .catch()

function asyncOperation() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error("Promise rejected!"));
    }, 1000);
  });
}

asyncOperation()
  .then((data) => console.log(data))
  .catch((error) => console.error("Caught a promise error:", error.message));

Example with async/await and try...catch

async function doAsyncWork() {
  try {
    await asyncOperation();
  } catch (error) {
    console.error("Caught async/await error:", error.message);
  }
}

doAsyncWork();

5. Global Error Handling (Express.js Example)

In a Node.js Express application, it’s common to set up global error handling middleware to manage all errors from different routes.

Global Error Handler Middleware

const express = require("express");
const app = express();

// Custom error class

class ApiError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}

// Example route
app.get("/", (req, res) => {
  throw new ApiError("Something went wrong!", 500);
});

// Global error handler middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(err.statusCode || 500).json({
    status: "error",
    message: err.message,
  });
});

app.listen(3000, () => {
  console.log("Server running on port 3000");
});

Output when visiting the root route (/):

{
  "status": "error",
  "message": "Something went wrong!"
}

6. Handling Uncaught Exceptions and Rejections

In some cases, errors may go uncaught, especially in asynchronous code. Node.js provides a way to handle uncaught exceptions and unhandled promise rejections.

Uncaught Exceptions

process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err.message);
  process.exit(1); // It's a best practice to shut down the application
});

throw new Error("Uncaught Exception Example");

Unhandled Promise Rejections

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', reason.message);
  process.exit(1); // It's a best practice to shut down the application
});

new Promise((resolve, reject) => reject(new Error("Unhandled Rejection Example")));

7. Custom Validation Error Example

Here’s a practical example of using custom error handling for validation in a REST API:

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

function validateInput(data) {
  if (!data.username) {
    throw new ValidationError("Username is required");
  }
  if (!data.email.includes("@")) {
    throw new ValidationError("Invalid email address");
  }
}

try {
  validateInput({ username: "", email: "example.com" });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error(`Validation Error: ${error.message}`);
  } else {
    console.error(`Unknown Error: ${error.message}`);
  }
}
Output:
Validation Error: Username is required



Global Exception Handler:


In Node.js, error handling is crucial for building robust applications. A Global Exception Handler is a centralized mechanism to handle unhandled exceptions and errors that occur throughout the entire application. It ensures that unexpected errors are caught and properly managed, improving application reliability.

Here's how you can implement a Global Exception Handler in Node.js from scratch.

1. Understanding Error Handling in Node.js
Node.js has different types of errors that can occur in an application:

Synchronous errors: These are thrown immediately and can be caught using a try...catch block.
Asynchronous errors: These occur after an asynchronous operation and need special handling, like with promises or callback functions.
Unhandled rejections: These are promises that are rejected but not caught with a .catch() method.
Unhandled exceptions: Errors that are not caught anywhere in the code and cause the program to crash.

2. Setting Up a Global Exception Handler
In Node.js, we can handle global exceptions using events provided by the process object:

process.on('uncaughtException'): Handles uncaught exceptions (sync errors).
process.on('unhandledRejection'): Handles unhandled promise rejections (async errors).

3. Step-by-Step Implementation of Global Exception Handler

Example 1: Basic Global Exception Handler for Uncaught Exceptions
const express = require('express');
const app = express();

// Route that throws a synchronous error
app.get('/', (req, res) => {
  throw new Error('Synchronous Error!');
});

// Global Exception Handler for uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err.message);
  // Perform any cleanup or logging here
  process.exit(1);  // Exit the process with a failure code
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

In this example:

Any error not caught in the application will be handled by the global handler, logging the error and then terminating the process.

Example 2: Handling Unhandled Promise Rejections

When working with promises, errors that aren't caught with a .catch() can cause unhandled rejections.

const express = require('express');
const app = express();

// Async route that causes an unhandled rejection
app.get('/promise', (req, res) => {
  new Promise((resolve, reject) => {
    reject('Promise was rejected');
  });
  res.send('Check your console');
});

// Global handler for unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // Optionally perform any cleanup or logging here
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
In this example:

An unhandled promise rejection triggers the unhandledRejection event, which is logged globally.

Example 3: Using Middleware for Error Handling in Express

In Express.js applications, it's common to handle exceptions with middleware. Here’s an example where errors occurring in routes are caught by a centralized error-handling middleware.

const express = require('express');
const app = express();

// Middleware to simulate an error
app.get('/', (req, res, next) => {
  // Simulate a runtime error
  next(new Error('Something went wrong!'));
});

// Centralized error-handling middleware
app.use((err, req, res, next) => {
  console.error('Error caught:', err.message);
  res.status(500).send('Internal Server Error');
});

// Global handler for uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err.message);
  process.exit(1);
});

// Global handler for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', promise, 'reason:', reason);
  process.exit(1);
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});

In this example:

The app.use function is used to define an error-handling middleware that logs the error and returns a 500 status code.
The global handlers for uncaught exceptions and unhandled rejections still capture errors that 
bypass Express's middleware.

4. Advanced Global Error Handling

In more complex applications, you might want to create a dedicated error-handling module that logs errors, performs cleanup, or sends notifications. Here's an example where we integrate advanced logging and email notifications:

const express = require('express');
const app = express();
const nodemailer = require('nodemailer');

// Function to send email when an error occurs
const sendErrorNotification = (error) => {
  // Set up email transport (you can use an actual email service here)
  const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
      user: 'your-email@gmail.com',
      pass: 'your-email-password'
    }
  });

  const mailOptions = {
    from: 'your-email@gmail.com',
    to: 'admin@example.com',
    subject: 'Error Notification',
    text: `Error: ${error.message}`
  };

  transporter.sendMail(mailOptions, (err, info) => {
    if (err) console.error('Error sending email:', err);
    else console.log('Error notification sent:', info.response);
  });
};

// Express error handling middleware
app.use((err, req, res, next) => {
  console.error('Error caught:', err.message);
  sendErrorNotification(err);
  res.status(500).send('Internal Server Error');
});

// Global handler for uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err.message);
  sendErrorNotification(err);
  process.exit(1);
});

// Global handler for unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  sendErrorNotification(reason);
  process.exit(1);
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});

In this example:

When an error is caught, an email notification is sent using Nodemailer.
This is useful for logging critical errors and notifying administrators in production environments.

5. Best Practices for Global Exception Handling

Graceful Shutdown: Ensure that after catching an exception, the server shuts down gracefully, allowing ongoing requests to finish.
Logging: Always log errors with enough details (stack traces) to diagnose the issue.
Avoid Silent Failures: Ensure that you handle all rejections and exceptions. Don’t ignore errors.
Monitoring Tools: Use tools like Sentry or Datadog for monitoring unhandled exceptions in production environments.


Processing query strings:


Processing query strings in HTTP requests is a common task in Node.js when you need to extract and manipulate data sent by the client in a URL. Query strings are the part of the URL that comes after the question mark (?) and are used to pass data to the server.

In this explanation, I'll guide you through how to handle query strings using HTTP in Node.js from scratch, followed by different examples.

1. Basic Node.js HTTP Server

We can use Node.js’s built-in http module to create an HTTP server and extract the query string from the request URL.

Here's how you can do it from scratch:

Step 1: Create a Basic HTTP Server

const http = require('http');
const url = require('url');

// Create an HTTP server
const server = http.createServer((req, res) => {
    // Parse the URL
    const parsedUrl = url.parse(req.url, true);
    
    // Extract the query object
    const queryObject = parsedUrl.query;
    
    // Write response headers
    res.writeHead(200, { 'Content-Type': 'application/json' });
    
    // Send the query object as a JSON response
    res.end(JSON.stringify(queryObject));
});

// Listen on port 3000
server.listen(3000, () => {
    console.log('Server is listening on port 3000');
});

Explanation:

We use the http.createServer() method to create an HTTP server.
The url.parse() method parses the URL and sets true as the second argument to get the query parameters as an object.
The queryObject contains the key-value pairs from the query string.

Example:
If you visit http://localhost:3000/?name=John&age=30 in your browser, the server will respond with:

{
    "name": "John",
    "age": "30"
}

2. Using Query Strings with Multiple Parameters

Let's enhance the example to process a URL with multiple query parameters.

const http = require('http');
const url = require('url');

// Create an HTTP server
const server = http.createServer((req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const queryObject = parsedUrl.query;

    // Extract multiple parameters
    const name = queryObject.name || 'Unknown';
    const age = queryObject.age || 'Unknown';
    const city = queryObject.city || 'Unknown';

    // Write the response with extracted parameters
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end(`Hello, ${name}! You are ${age} years old and from ${city}.`);
});

// Listen on port 3000
server.listen(3000, () => {
    console.log('Server is running at http://localhost:3000/');
});

Example:

Visiting http://localhost:3000/?name=Jane&age=25&city=New%20York will give the following response:

Hello, Jane! You are 25 years old and from New York.

3. Handling Missing Query Parameters

You can handle missing query parameters by setting default values or returning an error message.

const http = require('http');
const url = require('url');

// Create an HTTP server
const server = http.createServer((req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const queryObject = parsedUrl.query;

    if (!queryObject.name || !queryObject.age) {
        res.writeHead(400, { 'Content-Type': 'text/plain' });
        return res.end('Missing query parameters: name and age are required.');
    }

    const name = queryObject.name;
    const age = queryObject.age;

    // Write the response with extracted parameters
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end(`Hello, ${name}! You are ${age} years old.`);
});

// Listen on port 3000
server.listen(3000, () => {
    console.log('Server is running at http://localhost:3000/');
});

Example:

Visiting http://localhost:3000/?name=John&age=30 will work.

Visiting http://localhost:3000/?name=John will give the error message:


Missing query parameters: name and age are required.

4. Advanced: Using URLSearchParams for Modern Query String Handling

In modern Node.js versions (since v10.0.0), you can use the URLSearchParams API to work with query strings.

const http = require('http');

// Create an HTTP server
const server = http.createServer((req, res) => {
    const urlObj = new URL(req.url, `http://${req.headers.host}`);
    const searchParams = urlObj.searchParams;

    const name = searchParams.get('name') || 'Guest';
    const age = searchParams.get('age') || 'Unknown';
    const city = searchParams.get('city') || 'Unknown';

    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end(`Hello, ${name}! Age: ${age}. City: ${city}.`);
});

// Listen on port 3000
server.listen(3000, () => {
    console.log('Server is running at http://localhost:3000/');
});

Benefits of URLSearchParams:

Provides an easy and modern way to work with query strings.
searchParams.get() is cleaner for fetching values.

Example:
Visiting http://localhost:3000/?name=Sam&age=29&city=Boston will give:

Hello, Sam! Age: 29. City: Boston.

5. Handling Array Parameters in Query Strings

Query strings can also contain arrays, where multiple values are associated with the same key. For example, http://localhost:3000/?items=apple&items=banana&items=cherry.

const http = require('http');

// Create an HTTP server
const server = http.createServer((req, res) => {
    const urlObj = new URL(req.url, `http://${req.headers.host}`);
    const searchParams = urlObj.searchParams;

    // Get all values for 'items' as an array
    const items = searchParams.getAll('items');

    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ items }));
});

// Listen on port 3000
server.listen(3000, () => {
    console.log('Server is running at http://localhost:3000/');
});
Example:
Visiting http://localhost:3000/?items=apple&items=banana&items=cherry will give:

{
    "items": ["apple", "banana", "cherry"]
}

6. Using a Framework (Express.js)

In real-world applications, you often use a framework like Express.js for easier handling of query parameters.

const express = require('express');
const app = express();

// Route with query parameters
app.get('/', (req, res) => {
    const { name = 'Guest', age = 'Unknown', city = 'Unknown' } = req.query;
    res.send(`Hello, ${name}! Age: ${age}. City: ${city}.`);
});

// Start the server
app.listen(3000, () => {
    console.log('Server is running on http://localhost:3000');
});

Example:

Visiting http://localhost:3000/?name=Mike&age=34&city=Chicago will give:

Hello, Mike! Age: 34. City: Chicago.

