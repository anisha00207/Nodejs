Need for State Management Libraries in Angular :

ğŸ“Œ Why Do We Need State Management Libraries in Angular?
As your Angular application grows in complexity, managing the state (data shared across components) becomes challenging. State management libraries provide a structured way to manage and share data, making your application more scalable, maintainable, and predictable.

âœ… Understanding State in Angular
In Angular, state refers to the data used across components (e.g., user information, API responses, form data). There are three common types of states:

Local State â€“ Data specific to a component (e.g., form input).

Shared State â€“ Data shared between sibling components (e.g., user authentication).

Global State â€“ Data available across the entire application (e.g., user session, theme settings).

ğŸ“Š Problems Without a State Management Library
Data Inconsistency: Manually managing shared data can lead to data mismatch across components.

Complex Communication: Passing data using @Input() and @Output() becomes cumbersome with deep component hierarchies.

Unmanageable Logic: Large applications have complex business logic which is difficult to maintain without a clear structure.

Debugging Challenges: Tracking and debugging state changes becomes hard without a centralized solution.

ğŸš€ Why Use a State Management Library in Angular?
State management libraries like NgRx, Akita, or NgXs provide a structured way to manage state with these benefits:

Feature	Without State Management	With State Management Library
State Handling	Manual via @Input(), @Output()	Centralized, predictable state store
Component Coupling	High (tight data binding)	Low (decoupled components)
Scalability	Difficult to scale	Easily scalable and maintainable
Performance	Manual optimizations	Efficient via optimized change detection
Debugging	Hard to track changes	Easier via state logging (e.g., Redux DevTools)
Asynchronous Data	Complex to manage	Simplified with effects and observables

ğŸ“š Popular Angular State Management Libraries

NgRx (Redux for Angular)

Inspired by the Redux pattern (a unidirectional data flow).

Uses Actions, Reducers, Selectors, and Effects.

Best for large-scale applications with complex states.

Akita

Simplified state management with an RxJS-based approach.

Less boilerplate than NgRx and supports Entity Management.

Best for medium-to-large applications.

NgXs

State management with minimal boilerplate using a simple class-based structure.

Easier to learn and works well for small-to-medium applications.

SignalStore (Angular Signals)

Uses Angularâ€™s new signal API for optimized performance.

Suitable for modern Angular applications (Angular v17+).

ğŸ“ When to Use a State Management Library
âœ… Use State Management Library If:

Your application is large and complex (e.g., e-commerce platforms).

You need to share data between multiple parts of the application.

Your application has complex side effects (e.g., handling API calls).

You want a predictable and traceable state flow.

âŒ Donâ€™t Use If:

Your application is small (e.g., a to-do app).

State management via services is sufficient.

ğŸ“Š Real-World Example: Without vs. With NgRx

ğŸŸ¢ Without NgRx (Using Services)

Service to Hold State:

@Injectable({ providedIn: 'root' })
export class UserService {
  private user = new BehaviorSubject<User | null>(null);
  user$ = this.user.asObservable();

  setUser(user: User) {
    this.user.next(user);
  }
}
Component Usage:

@Component({...})
export class ProfileComponent {
  user$ = this.userService.user$;

  constructor(private userService: UserService) {}
}
ğŸ”µ With NgRx (State Management)

Action:

export const loadUser = createAction('[User] Load User', props<{ user: User }>());

Reducer:

export const userReducer = createReducer(initialState,
  on(loadUser, (state, { user }) => ({ ...state, user }))
);

Component Usage:

@Component({...})
export class ProfileComponent {
  user$ = this.store.select(selectUser);

  constructor(private store: Store) {
    this.store.dispatch(loadUser({ user: { name: 'John' } }));
  }
}
âœ… Advantages of NgRx:

Centralized state.

Debuggable via Redux DevTools.

Scales easily.

ğŸ“Œ Summary

Why State Management? To handle complex, shared, and dynamic data across Angular applications.

Key Benefits: Scalability, maintainability, performance, and better debugging.

Popular Libraries: NgRx, Akita, NgXs, SignalStore.

When to Use: For large applications or when you need better state handling.


Principles of Redux in Angular :

Redux is a state management library that helps manage application data in a predictable and centralized manner. In Angular, we often use NgRx (Angularâ€™s Reactive Extension for Redux) to implement the Redux pattern.

ğŸ“Œ Core Principles of Redux
Single Source of Truth:
The entire application state is stored in a single object called the store.

State is Read-Only:
The only way to change the state is by dispatching an action.

Changes are Made with Pure Functions:
State updates are performed using pure reducers, ensuring predictability and immutability.

ğŸ“Š Redux Workflow in Angular
Store: Holds the entire state of the application.

Actions: Events that describe changes to the state.

Reducers: Pure functions that determine how the state changes.

Selectors: Retrieve and derive data from the store.

Effects (Optional): Handle asynchronous operations (e.g., API calls).

ğŸ› ï¸ Example 1: Basic Counter Using NgRx

âœ… Step 1: Set Up NgRx in Angular

Install NgRx:

ng add @ngrx/store

Ensure StoreModule is imported in app.module.ts.

âœ… Step 2: Define the Counter State ğŸ“Œ src/app/store/counter.state.ts

export interface CounterState {
  count: number;
}

export const initialState: CounterState = {
  count: 0,
};

âœ… Step 3: Create Actions ğŸ“Œ src/app/store/counter.actions.ts

import { createAction } from '@ngrx/store';

export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');
export const reset = createAction('[Counter] Reset');

âœ… Step 4: Create the Reducer ğŸ“Œ src/app/store/counter.reducer.ts

import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';
import { CounterState, initialState } from './counter.state';

export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => ({ ...state, count: state.count + 1 })),
  on(decrement, (state) => ({ ...state, count: state.count - 1 })),
  on(reset, (state) => ({ ...state, count: 0 }))
);

âœ… Step 5: Register the Reducer ğŸ“Œ src/app/app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { StoreModule } from '@ngrx/store';
import { AppComponent } from './app.component';
import { counterReducer } from './store/counter.reducer';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    StoreModule.forRoot({ counter: counterReducer })
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

âœ… Step 6: Connect the UI ğŸ“Œ src/app/app.component.ts

import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment, decrement, reset } from './store/counter.actions';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  count$: Observable<number>;

  constructor(private store: Store<{ counter: { count: number } }>) {
    this.count$ = this.store.select((state) => state.counter.count);
  }

  onIncrement() {
    this.store.dispatch(increment());
  }

  onDecrement() {
    this.store.dispatch(decrement());
  }

  onReset() {
    this.store.dispatch(reset());
  }
}
âœ… Step 7: Design the Template ğŸ“Œ src/app/app.component.html

<div class="container">
  <h1>Angular Redux (NgRx) Counter</h1>
  
  <h2>Count: {{ count$ | async }}</h2>
  
  <button (click)="onIncrement()">Increment</button>
  <button (click)="onDecrement()">Decrement</button>
  <button (click)="onReset()">Reset</button>
</div>

âœ… Step 8: Run the Application

ng serve

ğŸ§‘â€ğŸ’» Example 2: Asynchronous State Using NgRx Effects

If you want to handle API calls asynchronously, you need to:

Install the @ngrx/effects package:

ng add @ngrx/effects

Create actions for loadSuccess and loadFailure.

Implement an Effect to call the API.

Dispatch actions on success or failure.

âœ… Step 1: Define Asynchronous Actions ğŸ“Œ store/user.actions.ts

import { createAction, props } from '@ngrx/store';

export const loadUsers = createAction('[User] Load Users');
export const loadUsersSuccess = createAction('[User] Load Users Success', props<{ users: any[] }>());
export const loadUsersFailure = createAction('[User] Load Users Failure', props<{ error: string }>());

âœ… Step 2: Create the Effect ğŸ“Œ store/user.effects.ts

import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { catchError, map, of, switchMap } from 'rxjs';
import { UserService } from '../user.service';
import { loadUsers, loadUsersSuccess, loadUsersFailure } from './user.actions';

@Injectable()
export class UserEffects {
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(loadUsers),
      switchMap(() =>
        this.userService.getUsers().pipe(
          map((users) => loadUsersSuccess({ users })),
          catchError((error) => of(loadUsersFailure({ error })))
        )
      )
    )
  );

  constructor(private actions$: Actions, private userService: UserService) {}
}
âœ… Step 3: Register the Effect ğŸ“Œ app.module.ts

import { EffectsModule } from '@ngrx/effects';
import { UserEffects } from './store/user.effects';

@NgModule({
  imports: [
    EffectsModule.forRoot([UserEffects])
  ]
})
export class AppModule {}

âœ… Step 4: Trigger API Call Dispatch the loadUsers() action in ngOnInit() to fetch data from the API.

ğŸ“˜ Summary

Actions: Define what you want to do.

Reducers: Specify how the state changes.

Store: Holds the global application state.

Effects: Handle side effects (API calls).

Selectors: Extract data from the store.


NGRX  in Angular :

NGRX is a state management library for Angular applications, inspired by the Redux pattern. It helps you manage the global state of your application in a predictable and consistent manner by using:

Actions â€“ Define events in the app.

Reducers â€“ Manage state transitions.

Selectors â€“ Retrieve specific parts of the state.

Effects â€“ Handle asynchronous operations (like API calls).

Store â€“ Centralized storage for the application state.

ğŸ“š Why Use NGRX?

Centralized State Management â€“ Single source of truth for the entire app.

Predictable State Changes â€“ State updates only via actions and reducers.

Debugging Tools â€“ Works well with the Redux DevTools extension.

Asynchronous Handling â€“ Manage complex side effects via Effects.

Scalability â€“ Ideal for large-scale Angular applications.

ğŸ“Œ Step-by-Step Guide: Setting Up NGRX in Angular

ğŸ”¹ Step 1: Set Up a New Angular Project

ng new ngrx-demo
cd ngrx-demo

ğŸ”¹ Step 2: Install NGRX Packages

ng add @ngrx/store
ng add @ngrx/effects
ng add @ngrx/store-devtools
ng add @ngrx/entity

ğŸ”¹ Step 3: Create a Simple Counter App Using NGRX

âœ… 1. Define Actions (counter.actions.ts)

Actions represent the events that describe state changes.

ğŸ“Œ src/app/state/counter.actions.ts

import { createAction } from '@ngrx/store';

// Define Counter Actions
export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');
export const reset = createAction('[Counter] Reset');

âœ… 2. Create Reducer (counter.reducer.ts)

Reducers specify how the state should change in response to actions.

ğŸ“Œ src/app/state/counter.reducer.ts

import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

// Initial State
export const initialState = 0;

// Reducer Function
export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => state + 1),
  on(decrement, (state) => state - 1),
  on(reset, () => 0)
);

âœ… 3. Register Reducer in App Module

ğŸ“Œ src/app/app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { StoreModule } from '@ngrx/store';
import { counterReducer } from './state/counter.reducer';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    StoreModule.forRoot({ counter: counterReducer }) // Register Reducer
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule { }

âœ… 4. Update the Component (app.component.ts)

ğŸ“Œ src/app/app.component.ts

import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment, decrement, reset } from './state/counter.actions';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  counter$ = this.store.select('counter'); // Select state from store

  constructor(private store: Store<{ counter: number }>) {}

  onIncrement() {
    this.store.dispatch(increment());
  }

  onDecrement() {
    this.store.dispatch(decrement());
  }

  onReset() {
    this.store.dispatch(reset());
  }
}

âœ… 5. Build the UI (app.component.html)

ğŸ“Œ src/app/app.component.html

<div style="text-align: center;">
  <h1>Angular NGRX Counter</h1>

  <h2>Counter: {{ counter$ | async }}</h2>

  <button (click)="onIncrement()">Increment</button>
  <button (click)="onDecrement()">Decrement</button>
  <button (click)="onReset()">Reset</button>
</div>
âœ… Run the App:

ng serve

ğŸ‰ You now have a fully functional NGRX-based counter!

ğŸ“Œ Example 2: Asynchronous State Management Using NGRX Effects

Goal: Fetch a list of products from an API.

ğŸ”¹ Step 1: Create the Product Model

ğŸ“Œ src/app/models/product.model.ts

export interface Product {
  id: number;
  name: string;
  price: number;
}

ğŸ”¹ Step 2: Create Product Service

ğŸ“Œ src/app/services/product.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Product } from '../models/product.model';

@Injectable({
  providedIn: 'root',
})
export class ProductService {
  private apiUrl = 'https://fakestoreapi.com/products';

  constructor(private http: HttpClient) {}

  getProducts(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl);
  }
}
ğŸ”¹ Step 3: Define Actions
ğŸ“Œ src/app/state/product.actions.ts

import { createAction, props } from '@ngrx/store';
import { Product } from '../models/product.model';

export const loadProducts = createAction('[Product] Load Products');
export const loadProductsSuccess = createAction(
  '[Product] Load Products Success',
  props<{ products: Product[] }>()
);
export const loadProductsFailure = createAction(
  '[Product] Load Products Failure',
  props<{ error: string }>()
);

ğŸ”¹ Step 4: Create Reducer

ğŸ“Œ src/app/state/product.reducer.ts

import { createReducer, on } from '@ngrx/store';
import { loadProductsSuccess } from './product.actions';
import { Product } from '../models/product.model';

export interface ProductState {
  products: Product[];
}

export const initialState: ProductState = {
  products: [],
};

export const productReducer = createReducer(
  initialState,
  on(loadProductsSuccess, (state, { products }) => ({
    ...state,
    products,
  }))
);

ğŸ”¹ Step 5: Create Effects

ğŸ“Œ src/app/state/product.effects.ts

import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { ProductService } from '../services/product.service';
import { loadProducts, loadProductsSuccess } from './product.actions';
import { mergeMap, map } from 'rxjs/operators';

@Injectable()
export class ProductEffects {
  loadProducts$ = createEffect(() =>
    this.actions$.pipe(
      ofType(loadProducts),
      mergeMap(() =>
        this.productService.getProducts().pipe(
          map((products) => loadProductsSuccess({ products }))
        )
      )
    )
  );

  constructor(
    private actions$: Actions,
    private productService: ProductService
  ) {}
}

ğŸ”¹ Step 6: Register in App Module

Add to StoreModule.forRoot() and EffectsModule.forRoot().

ğŸ”¹ Step 7: Trigger Effect in Component

Dispatch loadProducts() on component init and display products.

âœ… Run the Application:

ng serve

ğŸš€ Summary

Actions â€“ Trigger events.

Reducers â€“ Update state.

Effects â€“ Handle async tasks.

Selectors â€“ Retrieve specific data.


Store in Angular :

ğŸ›’ Understanding Store in Angular (State Management)
In Angular, State Management is crucial for handling shared data across components. The Store pattern is used to manage application states effectively.

âœ… What is a Store in Angular?
A Store in Angular is a centralized location to manage the application state. It acts as a single source of truth for data and allows components to access and update the state efficiently.

ğŸ§  Why Use a Store?
Centralized State: Keep all your application data in one place.

Component Communication: Share data between sibling or nested components.

Immutable State: Use pure functions to maintain predictable updates.

Debugging: Easier to track state changes using Redux DevTools.

ğŸ”¥ Approaches to State Management in Angular
Service-based Store (Simple) â€“ Ideal for small applications.

BehaviorSubject (RxJS) â€“ Works well with reactive patterns.

NgRx (Redux for Angular) â€“ Best for large-scale apps needing advanced state handling.

Akita â€“ A lightweight alternative to NgRx.

Signal-based Store â€“ Introduced in Angular 17 for better reactivity.

ğŸ“Œ 1. Service-based Store (Simple Approach)
A Service-based Store manages the application's shared data using simple Angular Services.

â¤ Step 1: Create a Store Service
ğŸ“Œ product.store.ts

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class ProductStore {
  private products: string[] = ['Laptop', 'Phone', 'Tablet'];

  getProducts(): string[] {
    return this.products;
  }

  addProduct(product: string): void {
    this.products.push(product);
  }
}

â¤ Step 2: Use the Store in a Component

ğŸ“Œ app.component.ts

import { Component } from '@angular/core';
import { ProductStore } from './product.store';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent {
  products: string[] = [];

  constructor(private productStore: ProductStore) {
    this.products = this.productStore.getProducts();
  }

  addProduct(newProduct: string) {
    this.productStore.addProduct(newProduct);
    this.products = this.productStore.getProducts();
  }
}

â¤ Step 3: Create UI

ğŸ“Œ app.component.html

<h2>Simple Angular Store Example</h2>
<ul>
  <li *ngFor="let product of products">{{ product }}</li>
</ul>

<input #newProduct type="text" placeholder="Add Product">
<button (click)="addProduct(newProduct.value)">Add</button>

âœ… Run:

ng serve

ğŸ“Œ 2. BehaviorSubject Store (RxJS Approach)

When you need reactivity and real-time updates, use BehaviorSubject.

â¤ Step 1: Create a Reactive Store

ğŸ“Œ cart.store.ts

import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class CartStore {
  private cartItems = new BehaviorSubject<string[]>([]);
  
  getCartItems(): Observable<string[]> {
    return this.cartItems.asObservable();
  }

  addItem(item: string) {
    const updatedCart = [...this.cartItems.value, item];
    this.cartItems.next(updatedCart);
  }
}

â¤ Step 2: Use the Cart Store

ğŸ“Œ cart.component.ts

import { Component } from '@angular/core';
import { CartStore } from './cart.store';

@Component({
  selector: 'app-cart',
  templateUrl: './cart.component.html',
})
export class CartComponent {
  cartItems$ = this.cartStore.getCartItems();

  constructor(private cartStore: CartStore) {}

  addItem(item: string) {
    this.cartStore.addItem(item);
  }
}

â¤ Step 3: Create Cart UI

ğŸ“Œ cart.component.html

<h2>Shopping Cart</h2>

<ul>
  <li *ngFor="let item of (cartItems$ | async)">{{ item }}</li>
</ul>

<input #item type="text" placeholder="Add Item">
<button (click)="addItem(item.value)">Add to Cart</button>
âœ… Run:

ng serve

ğŸ“Œ 3. NgRx Store (Advanced State Management)

NgRx is a powerful Redux-based state management solution for large-scale Angular applications.

â¤ Step 1: Install NgRx

ng add @ngrx/store

â¤ Step 2: Create State

ğŸ“Œ state/product.state.ts

export interface ProductState {
  products: string[];
}

export const initialState: ProductState = {
  products: ['Laptop', 'Tablet'],
};

â¤ Step 3: Create Actions

ğŸ“Œ state/product.actions.ts

import { createAction, props } from '@ngrx/store';

export const addProduct = createAction('[Product] Add', props<{ product: string }>());

â¤ Step 4: Create Reducer

ğŸ“Œ state/product.reducer.ts

import { createReducer, on } from '@ngrx/store';
import { addProduct } from './product.actions';
import { initialState } from './product.state';

export const productReducer = createReducer(
  initialState,
  on(addProduct, (state, { product }) => ({
    ...state,
    products: [...state.products, product],
  }))
);

â¤ Step 5: Register the Store

ğŸ“Œ app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { StoreModule } from '@ngrx/store';
import { productReducer } from './state/product.reducer';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, StoreModule.forRoot({ products: productReducer })],
  bootstrap: [AppComponent],
})
export class AppModule {}

â¤ Step 6: Use the Store in a Component

ğŸ“Œ app.component.ts

import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { addProduct } from './state/product.actions';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent {
  products$: Observable<string[]>;

  constructor(private store: Store<{ products: string[] }>) {
    this.products$ = this.store.select('products');
  }

  addProduct(product: string) {
    this.store.dispatch(addProduct({ product }));
  }
}

â¤ Step 7: Create UI

ğŸ“Œ app.component.html

<h2>NgRx Store Example</h2>

<ul>
  <li *ngFor="let product of (products$ | async)">{{ product }}</li>
</ul>

<input #product type="text" placeholder="Add Product">
<button (click)="addProduct(product.value)">Add Product</button>

âœ… Run:

ng serve

ğŸ› ï¸ Which Store Should You Use?

Store Type	Use Case
Service Store	Small apps, simple requirements
RxJS Store	Medium apps, reactive updates
NgRx Store	Large, complex applications
Signal Store	Future-proof, Angular 17+ apps


Actions in Angular :

In Angular, Actions typically refer to user interactions (such as clicks, form submissions, etc.) or programmatic events that trigger specific logic. Actions are fundamental in Angularâ€™s event-driven architecture and are usually handled via event binding, service interactions, and state management (like NgRx actions).

Letâ€™s break down the concept of Actions in Angular with practical examples and real-world use cases.

ğŸ”¥ 1. Basic Actions using Event Binding
Event binding in Angular allows you to respond to DOM events like clicks, keypresses, and input changes.

Example: Button Click Action
ğŸ“Œ app.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  message: string = '';

  onButtonClick() {
    this.message = 'Button Clicked!';
  }
}

ğŸ“Œ app.component.html

<h2>Basic Action - Click Event</h2>

<button (click)="onButtonClick()">Click Me</button>
<p>{{ message }}</p>

âœ… Explanation:

(click): Angular event binding syntax.

onButtonClick(): Action triggered when the button is clicked.

ğŸ“¥ 2. Input Actions â€“ Handling Form Inputs

Capture and process user input using Angularâ€™s ngModel and input events.

Example: Capture User Input in Real-time

ğŸ“Œ app.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  inputValue: string = '';

  onInputChange(event: Event) {
    this.inputValue = (event.target as HTMLInputElement).value;
  }
}
ğŸ“Œ app.component.html

<h2>Input Event Action</h2>

<input type="text" (input)="onInputChange($event)" placeholder="Type here">
<p>You typed: {{ input Value }}</p>

âœ… Explanation:

(input): Triggers on each keystroke.

event.target.value: Extracts input value from the event.

ğŸ”„ 3. Two-Way Data Binding Action

Using [(ngModel)] enables a bi-directional data flow between the view and the component.

Example: Sync Input and Component Property

ğŸ“Œ app.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  name: string = 'Angular';
}
ğŸ“Œ app.component.html

<h2>Two-Way Binding Action</h2>

<input [(ngModel)]="name" placeholder="Enter name">
<p>Hello, {{ name }}!</p>

âœ… Explanation:

[(ngModel)]: Two-way binding for syncing view and data.

Ensure FormsModule is imported in app.module.ts:

import { FormsModule } from '@angular/forms';
@NgModule({
  imports: [FormsModule]
})

ğŸ“Š 4. Action via Custom Event Emitting

Communicate between child and parent components using @Output() and EventEmitter.

Example: Emit Action from Child to Parent

ğŸ“Œ child.component.ts

import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<button (click)="sendMessage()">Send Message</button>`
})

export class ChildComponent {
  @Output() messageEvent = new EventEmitter<string>();

  sendMessage() {
    this.messageEvent.emit('Hello from Child!');
  }
}

ğŸ“Œ parent.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html'
})
export class ParentComponent {
  receivedMessage = '';

  onMessageReceived(message: string) {
    this.receivedMessage = message;
  }
}
ğŸ“Œ parent.component.html

<h2>Child to Parent Communication</h2>

<app-child (messageEvent)="onMessageReceived($event)"></app-child>
<p>{{ receivedMessage }}</p>
âœ… Explanation:

@Output(): Decorator for output properties.

EventEmitter: Emits custom events.

(messageEvent): Handles the emitted event.

ğŸ”¥ 5. Service-Based Actions
Use services to share data or trigger actions across multiple components.

Example: Data Sharing via Service
ğŸ“Œ data.service.ts

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class DataService {
  private messageSource = new BehaviorSubject<string>('Initial Message');
  currentMessage = this.messageSource.asObservable();

  changeMessage(message: string) {
    this.messageSource.next(message);
  }
}
ğŸ“Œ sender.component.ts

import { Component } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-sender',
  template: `<button (click)="sendMessage()">Send Data</button>`
})
export class SenderComponent {
  constructor(private dataService: DataService) {}

  sendMessage() {
    this.dataService.changeMessage('Hello from Sender');
  }
}
ğŸ“Œ receiver.component.ts

import { Component, OnInit } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-receiver',
  template: `<p>Received: {{ message }}</p>`
})
export class ReceiverComponent implements OnInit {
  message: string = '';

  constructor(private dataService: DataService) {}

  ngOnInit() {
    this.dataService.currentMessage.subscribe(msg => this.message = msg);
  }
}
âœ… Explanation:

BehaviorSubject: Manages and emits state.

changeMessage(): Updates shared state.

ğŸ“¦ 6. NgRx Actions (Advanced State Management)

In NgRx, actions represent events that trigger state changes in a centralized store.

Example: Basic Action Definition

ğŸ“Œ Define Action (counter.actions.ts):

import { createAction } from '@ngrx/store';

export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');

ğŸ“Œ Dispatch Action (app.component.ts):

import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment } from './store/counter.actions';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  constructor(private store: Store) {}

  onIncrement() {
    this.store.dispatch(increment());
  }
}

âœ… Explanation:

createAction: Defines a new action.

dispatch(): Dispatches action to the store.

ğŸ¯ Summary

Basic Actions: Handle UI events using (click), (input).

Two-Way Binding: Synchronize using [(ngModel)].

Custom Actions: Use @Output() and EventEmitter.

Service-Based Actions: Share data across components via RxJS.

NgRx Actions: Manage application-level state effectively.



Reducer in Angular :


In Angular, a reducer is a fundamental concept used in state management, especially with libraries like NgRx (Angular's reactive state management). It is inspired by the Redux pattern and is based on the principle of immutable state.

âœ… What is a Reducer?
A reducer is a pure function that takes the current state and an action as inputs and returns a new state.

Reducer Signature:

function reducer(state, action): newState

State: The current state of the application.

Action: An object that describes what happened (e.g., ADD_ITEM, REMOVE_ITEM).

New State: A copy of the updated state.

âœ… Why Use Reducers in Angular?
Predictable State: State changes happen in a controlled and consistent manner.

Scalability: Easily handle complex state management as the app grows.

Immutability: Ensures state is never mutated directly, promoting better debugging and traceability.

ğŸš€ Basic Example of a Reducer in Angular
Letâ€™s create a simple counter example using a reducer.

Step 1: Create the Counter Reducer

ğŸ“Œ counter.reducer.ts

import { Action } from '@ngrx/store';

// Step 1: Define Actions
export const INCREMENT = '[Counter] Increment';
export const DECREMENT = '[Counter] Decrement';
export const RESET = '[Counter] Reset';

// Step 2: Define State Type
export interface CounterState {
  count: number;
}

// Initial State
export const initialState: CounterState = {
  count: 0,
};

// Step 3: Create the Reducer
export function counterReducer(state = initialState, action: Action): CounterState {
  switch (action.type) {
    case INCREMENT:
      return { ...state, count: state.count + 1 };

    case DECREMENT:
      return { ...state, count: state.count - 1 };

    case RESET:
      return { ...state, count: 0 };

    default:
      return state; // Return current state if action not recognized
  }
}

Step 2: Set Up the State Management

ğŸ“Œ app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { StoreModule } from '@ngrx/store';
import { AppComponent } from './app.component';
import { counterReducer } from './counter.reducer';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    StoreModule.forRoot({ counter: counterReducer }), // Register Reducer
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}

Step 3: Use the Reducer in a Component
ğŸ“Œ app.component.ts

import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { INCREMENT, DECREMENT, RESET, CounterState } from './counter.reducer';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  count$ = this.store.select('counter');

  constructor(private store: Store<{ counter: CounterState }>) {}

  increment() {
    this.store.dispatch({ type: INCREMENT });
  }

  decrement() {
    this.store.dispatch({ type: DECREMENT });
  }

  reset() {
    this.store.dispatch({ type: RESET });
  }
}

Step 4: Display the State in the Template

ğŸ“Œ app.component.html

<h1>Counter: {{ (count$ | async)?.count }}</h1>

<button (click)="increment()">Increment</button>
<button (click)="decrement()">Decrement</button>
<button (click)="reset()">Reset</button>

âœ… Run the Application:

ng serve

âœ… Types of Reducers in Angular

1. Simple Reducer (As Above)
Manages basic operations with primitive data like numbers, strings, etc.

2. Complex Reducer with Objects
Handles nested objects and complex data structures.

ğŸ“Œ user.reducer.ts

import { Action } from '@ngrx/store';

export interface UserState {
  name: string;
  age: number;
}

export const initialState: UserState = {
  name: '',
  age: 0,
};

export const UPDATE_USER = '[User] Update';
export const RESET_USER = '[User] Reset';

export function userReducer(state = initialState, action: any): UserState {
  switch (action.type) {
    case UPDATE_USER:
      return { ...state, ...action.payload }; // Update partial fields

    case RESET_USER:
      return initialState; // Reset to initial state

    default:
      return state;
  }
}

3. List/Array Reducer

Manages collections like a to-do list.

ğŸ“Œ todo.reducer.ts

import { Action } from '@ngrx/store';

export interface Todo {
  id: number;
  text: string;
}

export const ADD_TODO = '[Todo] Add';
export const REMOVE_TODO = '[Todo] Remove';

export const initialState: Todo[] = [];

export function todoReducer(state = initialState, action: any): Todo[] {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];

    case REMOVE_TODO:
      return state.filter(todo => todo.id !== action.payload.id);

    default:
      return state;
  }
}

âœ… Advanced Reducer Features

Action Creators (using createAction from NgRx).

Handling Side Effects (with EffectsModule).

Combining Multiple Reducers using StoreModule.forRoot().

âœ… Best Practices for Reducers

Keep Reducers Pure â€“ No side effects like API calls.

Use Action Types Constants â€“ Avoid hardcoding action strings.

Immutable State Updates â€“ Always return a new copy of the state.

Structure State Clearly â€“ Organize reducers by feature module.


Effects in Angular :


In Angular, Effects are a key concept in NgRx (Angular Reactive Extensions) used for handling side effectsâ€”tasks like:

âœ… Fetching data from APIs
âœ… Writing logs
âœ… Navigating to a different route
âœ… Performing localStorage operations

ğŸ“Œ What is an Effect?

An Effect listens for actions dispatched to the store, performs side effects (e.g., API calls), and dispatches new actions with the result.

ğŸ“Š How Angular Effects Work

Action: Triggered by the UI or service (e.g., loadUsers).

Effect: Intercepts the action, calls the service (e.g., HTTP request).

Reducer: Updates the state based on the result (success/failure).

Component: Reflects the updated state in the UI.

ğŸ› ï¸ Step-by-Step Implementation of NgRx Effects in Angular
Let's create an Angular 19 app and implement NgRx Effects from scratch.

âœ… 1. Set Up Angular and NgRx

Create a new Angular project:

ng new ngrx-effects-demo
cd ngrx-effects-demo

Add NgRx dependencies:

ng add @ngrx/store @ngrx/effects

âœ… 2. Create a User Module (Feature Module)

ng generate module users
ng generate component users

âœ… 3. Define User Model

ğŸ“Œ src/app/users/models/user.model.ts

export interface User {
  id: number;
  name: string;
  email: string;
}
âœ… 4. Create User Actions

ğŸ“Œ src/app/users/state/user.actions.ts

import { createAction, props } from '@ngrx/store';
import { User } from '../models/user.model';

// Action to Load Users

export const loadUsers = createAction('[User] Load Users');

// Action on Successful API Response
export const loadUsersSuccess = createAction(
  '[User] Load Users Success',
  props<{ users: User[] }>()
);

// Action on API Error
export const loadUsersFailure = createAction(
  '[User] Load Users Failure',
  props<{ error: string }>()
);

âœ… 5. Create a User Reducer

ğŸ“Œ src/app/users/state/user.reducer.ts

import { createReducer, on } from '@ngrx/store';
import * as UserActions from './user.actions';
import { User } from '../models/user.model';

export interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
}

export const initialState: UserState = {
  users: [],
  loading: false,
  error: null,
};

export const userReducer = createReducer(
  initialState,

  // Handle Load Users
  on(UserActions.loadUsers, (state) => ({
    ...state,
    loading: true
  })),

  // Handle Success
  on(UserActions.loadUsersSuccess, (state, { users }) => ({
    ...state,
    users,
    loading: false
  })),

  // Handle Failure
  on(UserActions.loadUsersFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error
  }))
);

âœ… 6. Create a Mock API Service

ğŸ“Œ src/app/users/services/user.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { User } from '../models/user.model';

@Injectable({
  providedIn: 'root',
})
export class UserService {
  private apiUrl = 'https://jsonplaceholder.typicode.com/users';

  constructor(private http: HttpClient) {}

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }
}

âœ… 7. Create an Effect

ğŸ“Œ src/app/users/state/user.effects.ts

import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { catchError, map, of, switchMap } from 'rxjs';
import * as UserActions from './user.actions';
import { UserService } from '../services/user.service';

@Injectable()
export class UserEffects {
  constructor(private actions$: Actions, private userService: UserService) {}

  // Effect to Load Users
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers), // Listen for the loadUsers action
      switchMap(() =>
        this.userService.getUsers().pipe(
          map((users) => UserActions.loadUsersSuccess({ users })), // Dispatch success action
          catchError((error) =>
            of(UserActions.loadUsersFailure({ error: error.message }))
          )
        )
      )
    )
  );
}

âœ… 8. Register Reducer and Effects

ğŸ“Œ src/app/users/users.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { UsersComponent } from './users.component';
import { StoreModule } from '@ngrx/store';
import { userReducer } from './state/user.reducer';
import { EffectsModule } from '@ngrx/effects';
import { UserEffects } from './state/user.effects';

@NgModule({
  declarations: [UsersComponent],
  imports: [
    CommonModule,
    StoreModule.forFeature('users', userReducer),
    EffectsModule.forFeature([UserEffects]),
  ],
})
export class UsersModule {}
ğŸ“Œ src/app/app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { HttpClientModule } from '@angular/common/http';
import { StoreModule } from '@ngrx/store';
import { EffectsModule } from '@ngrx/effects';
import { UsersModule } from './users/users.module';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    UsersModule,
    StoreModule.forRoot({}),
    EffectsModule.forRoot([]),
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}

âœ… 9. Display Data in Component

ğŸ“Œ src/app/users/users.component.ts

import { Component, OnInit } from '@angular/core';
import { Store } from '@ngrx/store';
import { Observable } from 'rxjs';
import { loadUsers } from './state/user.actions';
import { UserState } from './state/user.reducer';

@Component({
  selector: 'app-users',
  templateUrl: './users.component.html',
})
export class UsersComponent implements OnInit {
  users$: Observable<any>;

  constructor(private store: Store<{ users: UserState }>) {
    this.users$ = this.store.select((state) => state.users);
  }

  ngOnInit(): void {
    this.store.dispatch(loadUsers());
  }
}
ğŸ“Œ src/app/users/users.component.html

<h2>User List</h2>
<div *ngIf="(users$ | async) as userState">
  <div *ngIf="userState.loading">Loading...</div>
  <div *ngIf="userState.error">{{ userState.error }}</div>
  <ul>
    <li *ngFor="let user of userState.users">{{ user.name }}</li>
  </ul>
</div>

âœ… 10. Run the Application

ng serve -o

ğŸ“š Different Types of Effects
API Call Effect: Handles asynchronous operations (like the example above).

Router Effects: Navigates to a different route based on action.

LocalStorage Effects: Stores/retrieves data from localStorage.

Multiple Actions Effect: Dispatch multiple actions from one effect.


Integrating Node, Express,Angular and MongoDB :

// Step 1: Set up the Node.js + Express.js Backend

// Install required packages:
// npm init -y
// npm install express mongoose cors

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');

const app = express();
const port = 3000;

// Middleware
app.use(cors());
app.use(express.json());

// MongoDB connection
mongoose.connect('mongodb://localhost:27017/mean-crud', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

const db = mongoose.connection;
db.on('error', console.error.bind(console, 'Connection error:'));
db.once('open', () => console.log('Connected to MongoDB'));

// Define Schema
const ItemSchema = new mongoose.Schema({
  name: String,
  description: String,
});

const Item = mongoose.model('Item', ItemSchema);

// CRUD APIs

// Create Item
app.post('/api/items', async (req, res) => {
  try {
    const item = new Item(req.body);
    await item.save();
    res.status(201).json(item);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// Read Items
app.get('/api/items', async (req, res) => {
  try {
    const items = await Item.find();
    res.json(items);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update Item
app.put('/api/items/:id', async (req, res) => {
  try {
    const item = await Item.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.json(item);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// Delete Item
app.delete('/api/items/:id', async (req, res) => {
  try {
    await Item.findByIdAndDelete(req.params.id);
    res.json({ message: 'Item deleted' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Start server
app.listen(port, () => console.log(`Server running on port ${port}`));

// Step 2: Angular Frontend

// Angular CLI setup:
// ng new mean-crud-client
// cd mean-crud-client
// ng generate component item

// Install Angular HTTP Client
// ng add @angular/common

// src/app/services/item.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

interface Item {
  _id?: string;
  name: string;
  description: string;
}

@Injectable({ providedIn: 'root' })
export class ItemService {
  private apiUrl = 'http://localhost:3000/api/items';

  constructor(private http: HttpClient) {}

  getItems(): Observable<Item[]> {
    return this.http.get<Item[]>(this.apiUrl);
  }

  addItem(item: Item): Observable<Item> {
    return this.http.post<Item>(this.apiUrl, item);
  }

  updateItem(id: string, item: Item): Observable<Item> {
    return this.http.put<Item>(`${this.apiUrl}/${id}`, item);
  }

  deleteItem(id: string): Observable<any> {
    return this.http.delete(`${this.apiUrl}/${id}`);
  }
}

// src/app/item/item.component.ts

import { Component, OnInit } from '@angular/core';
import { ItemService } from '../services/item.service';

@Component({
  selector: 'app-item',
  templateUrl: './item.component.html',
  styleUrls: ['./item.component.css'],
})
export class ItemComponent implements OnInit {
  items: any[] = [];
  newItem = { name: '', description: '' };

  constructor(private itemService: ItemService) {}

  ngOnInit(): void {
    this.loadItems();
  }

  loadItems() {
    this.itemService.getItems().subscribe((data) => (this.items = data));
  }

  addItem() {
    this.itemService.addItem(this.newItem).subscribe(() => {
      this.loadItems();
      this.newItem = { name: '', description: '' };
    });
  }

  deleteItem(id: string) {
    this.itemService.deleteItem(id).subscribe(() => this.loadItems());
  }
}

// src/app/item/item.component.html

<h2>Item Management</h2>
<div>
  <input [(ngModel)]="newItem.name" placeholder="Name" />
  <input [(ngModel)]="newItem.description" placeholder="Description" />
  <button (click)="addItem()">Add Item</button>
</div>

<ul>
  <li *ngFor="let item of items">
    {{ item.name }} - {{ item.description }}
    <button (click)="deleteItem(item._id)">Delete</button>
  </li>
</ul>

// src/app/item/item.component.css

h2 {
  color: #4CAF50;
}

input {
  margin: 5px;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  margin-left: 10px;
  padding: 8px 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #45a049;
} 

// Run Instructions:
// 1. Start MongoDB: mongod
// 2. Run backend: node server.js
// 3. Run Angular: ng serve

9652775808