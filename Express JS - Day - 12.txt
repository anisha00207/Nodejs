Environment Setup:

Express generator tool:

What is Express Generator?

Express Generator is a tool provided by Express.js (a Node.js web framework) to create the boilerplate structure of an Express application quickly. It helps developers set up a project with the common files, configurations, and folders, saving time and effort in manually organizing these structures.

Installation and Setup

Install Node.js and npm: Ensure that you have Node.js installed on your machine. This will also install npm (Node Package Manager) automatically.

Install Express Generator: To install Express Generator globally on your system, you can use the following command:

npm install -g express-generator

Create an Express Application: Once the Express Generator is installed, you can use it to generate a new Express application.

express myapp

This will generate an application skeleton in the myapp directory.

Install Dependencies: Navigate to the created directory and install all the required dependencies.


cd myapp
npm install
Run the Application: You can now start the application.

bash
Copy code
npm start
The server will run, usually on http://localhost:3000, unless configured otherwise.

Generated File Structure
When you run express myapp, the following directory structure is generated:


myapp/
├── bin/
│   └── www           # Script for starting the server
├── public/           # Static files (CSS, JavaScript, images)
│   ├── images/
│   ├── javascripts/
│   └── stylesheets/
├── routes/           # Application routes (home, user routes)
│   ├── index.js
│   └── users.js
├── views/            # Views (HTML templates like Jade, Pug)
│   └── error.jade
│   └── index.jade
│   └── layout.jade
├── app.js            # Main application file
├── package.json      # Project metadata and dependencies
└── README.md
Example 1: Basic Application

This example demonstrates the structure and functionality of a basic Express app.

Routes:

routes/index.js: This defines the homepage route.

var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express' });
});

module.exports = router;

routes/users.js: This defines the /users route.

var express = require('express');
var router = express.Router();

/* GET users listing. */
router.get('/', function(req, res, next) {
  res.send('respond with a resource');
});

module.exports = router;

Views:

Express by default uses Jade (now known as Pug) as the view engine. Here’s the main view file, 

views/index.jade:

extends layout

block content
  h1= title
  p Welcome to #{title}

The layout provides the basic HTML structure, and you can insert content blocks into it.

Example 2: Customizing the Application

Here’s how you can customize an Express app generated by Express Generator:

Switching the View Engine: You can switch from Pug (Jade) to another templating engine like EJS (Embedded JavaScript):

Install EJS:

npm install ejs

Modify app.js to use EJS instead of Pug:

app.set('view engine', 'ejs');

Create an index.ejs in the views/ folder:

<h1><%= title %></h1>
<p>Welcome to <%= title %></p>

Adding Middleware: You can add middleware for logging, body parsing, session handling, etc.

Install morgan for logging:

npm install morgan

Add it to app.js:

var logger = require('morgan');
app.use(logger('dev'));

Adding New Routes: You can add additional routes to handle different endpoints.

Create a new route in routes/products.js:

var express = require('express');
var router = express.Router();

/* GET products listing. */
router.get('/', function(req, res, next) {
  res.send('List of products');
});

module.exports = router;

Register the new route in app.js:


var productsRouter = require('./routes/products');
app.use('/products', productsRouter);

Example 3: Enabling Static File Serving

By default, the public/ folder is used to serve static files like CSS, JavaScript, and images.

Place a CSS file in public/stylesheets/style.css.

For example:


body {
  background-color: lightblue;
}

Reference this file in your view, like in views/index.jade:

extends layout

block content
  link(rel='stylesheet', href='/stylesheets/style.css')
  h1= title
  p Welcome to #{title}

Example 4: Using a JSON API

You can easily set up a REST API using the Express Generator.

Create a new route for the API in routes/api.js:

var express = require('express');
var router = express.Router();

/* GET API data */
router.get('/data', function(req, res, next) {
  res.json({ message: "Hello, API!" });
});

module.exports = router;


Register the API route in app.js:

js
Copy code
var apiRouter = require('./routes/api');
app.use('/api', apiRouter);
Access the API via http://localhost:3000/api/data, and you will receive:

{
  "message": "Hello, API!"
}
Example 5: Error Handling

Express Generator sets up basic error handling for you. You can customize it in the app.js file.

Handle 404 Errors: This code is already present in the generated app.js:

app.use(function(req, res, next) {
  next(createError(404));
});

Error Handler: Customize the error message display:

app.use(function(err, req, res, next) {
  // Set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // Render the error page
  res.status(err.status || 500);
  res.render('error', { error: err });
});


Before Express:

Pre-Express:

Pre-Express refers to the time or phase in Node.js development before the introduction or usage of the Express.js framework. In this phase, developers relied on Node.js's native HTTP module to build web applications and handle HTTP requests and responses.

Key Aspects of Pre-Express in Node.js:
Manual HTTP Server Creation: Before Express, developers had to use the built-in http and url modules to create servers and manage routing.

Example of a simple HTTP server without Express:

const http = require('http');
const url = require('url');

const server = http.createServer((req, res) => {
  const path = url.parse(req.url, true).pathname;

  if (path === '/') {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Welcome to the Home Page');
  } else if (path === '/about') {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Welcome to the About Page');
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('Page Not Found');
  }
});

server.listen(3000, () => {
  console.log('Server is running on port 3000');
});

This basic HTTP server handles requests but requires more manual work, such as parsing URLs, defining routes, handling request methods, and managing response content types.

Routing: In the pre-Express era, routing logic had to be manually written. This involved checking the URL path and handling different HTTP methods (GET, POST, etc.) with conditionals.

Example of routing without Express:

if (req.method === 'GET' && req.url === '/') {
  // Handle GET request to home page
}
As the application grew, this method became cumbersome because it lacked structure and required repeated code for each route.

Middleware Handling: There was no built-in middleware support. To implement features like logging, authentication, and parsing the request body, developers had to manually handle these aspects or use third-party libraries. For example, manually parsing the request body was more complex without Express's body-parser or built-in methods.

Limitations:

Lack of structured routing and middleware: Each route had to be defined separately.
Verbose: Writing complex applications with a lot of routes or logic became time-consuming and hard to maintain.
Limited scalability: Pre-Express applications were difficult to scale and lacked the modularity provided by a framework like Express.

Why Express Improved Node.js Development:

Simplified Routing: Express introduced a concise and declarative way to define routes, such as app.get(), app.post(), etc.
Middleware Support: Express provided built-in support for middleware, allowing developers to easily handle tasks like logging, body parsing, and error handling.
Extensibility: Express had a huge ecosystem of middleware and plugins that helped streamline development.
Cleaner Code: Express’s modular architecture made applications more maintainable and easier to read.
Example of an Express-based HTTP server:

javascript
Copy code
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Welcome to the Home Page');
});

app.get('/about', (req, res) => {
  res.send('Welcome to the About Page');
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});


How the Internet Works - TCP and UDP:


The internet is a global network of computers that communicate with each other using a standardized protocol suite called TCP/IP (Transmission Control Protocol/Internet Protocol). This suite defines how data is transmitted across networks and ensures reliable communication between devices. Let's break down how the internet works with a focus on TCP and UDP, which are two core protocols for communication.

1. IP (Internet Protocol)
At the foundation of the internet is the IP (Internet Protocol), which is responsible for addressing and routing data packets across networks. Every device connected to the internet has a unique IP address, and data is sent in packets, which are small chunks of the original message. The role of IP is to deliver these packets to the destination address.

However, IP itself doesn’t guarantee reliable delivery. That's where TCP and UDP come into play, providing different mechanisms for controlling data transmission.

2. TCP (Transmission Control Protocol)
TCP is a connection-oriented protocol, meaning it establishes a reliable connection between two devices before transmitting data. It ensures that the data is delivered accurately and in the correct order.

Key Features of TCP:

Connection Establishment: TCP uses a three-way handshake (SYN, SYN-ACK, ACK) to establish a connection between the sender and receiver before data transfer.
Data Integrity: TCP checks for errors and ensures all data packets are received correctly. If packets are lost or corrupted, TCP retransmits them.
Flow Control: TCP regulates the flow of data between devices to prevent overwhelming the receiver’s capacity.
Congestion Control: TCP adjusts the rate of data transmission based on the current network conditions, reducing data flow if the network is congested.
Guaranteed Delivery: TCP ensures that the data sent by the sender reaches the receiver in the same order and without loss.
How TCP Works:
Three-Way Handshake: Before sending data, TCP sets up a connection using a three-step process:

The sender sends a SYN (synchronize) packet to the receiver.
The receiver responds with a SYN-ACK (synchronize-acknowledge) packet.
The sender replies with an ACK (acknowledge) packet, and the connection is established.
Data Transmission: Once the connection is established, TCP breaks the message into segments, numbers them, and sends them. The receiver reassembles these segments in the correct order.

Acknowledgment and Retransmission: Each segment sent must be acknowledged by the receiver. If a segment is not acknowledged, TCP retransmits it, ensuring reliable delivery.

Common Uses of TCP:
Web Browsing (HTTP/HTTPS): Web pages are sent over TCP, ensuring they load correctly and completely.
Email (SMTP, IMAP, POP3): Email services rely on TCP to ensure messages are sent and received accurately.
File Transfer (FTP): TCP ensures files are transferred reliably.

3. UDP (User Datagram Protocol)

UDP is a connectionless protocol, meaning it sends data without establishing a connection and without ensuring reliable delivery. UDP is simpler and faster than TCP, but it does not provide guarantees for packet delivery, order, or integrity.

Key Features of UDP:
No Connection Setup: Unlike TCP, UDP doesn’t establish a connection before sending data.

No Guaranteed Delivery: UDP does not ensure that packets are delivered or that they arrive in the correct order. Lost or corrupted packets are not retransmitted.

Low Overhead: UDP has less communication overhead compared to TCP, making it faster but less reliable.
No Flow or Congestion Control: UDP does not manage data flow or network congestion.

How UDP Works:

Packet Transmission: Data is broken into datagrams and sent directly to the receiver without setting up a connection.
No Acknowledgment: Once the datagram is sent, UDP does not wait for any acknowledgment or retransmit lost data. It simply moves on.

Common Uses of UDP:

Streaming Media (Audio/Video): In applications like video streaming or live broadcasts, it's more important to deliver data quickly than to guarantee every packet is received. Small losses are acceptable.

Online Gaming: Many real-time multiplayer games use UDP because low latency is critical, and occasional packet loss is tolerable.

DNS (Domain Name System): DNS requests are small and can tolerate occasional packet loss, so they use UDP for speed.

4. Differences Between TCP and UDP

Feature	TCP	UDP
Connection	Connection-oriented (reliable)	Connectionless (unreliable)
Data Integrity	Guaranteed delivery	No guarantee of delivery
Ordering	Ensures correct order	No ordering
Error Recovery	Retransmits lost packets	No retransmission
Overhead	Higher overhead due to control	Lower overhead
Speed	Slower due to reliability measures	Faster, less reliable
Use Cases	Web browsing, file transfer, email	Streaming, gaming, DNS

5. How TCP and UDP Fit into the Internet

TCP is used when accuracy and reliability are more important than speed. For example, when you visit a website, the data must be delivered correctly, even if it takes slightly longer.
UDP is used when speed is more important than reliability, such as in live video streaming or online gaming, where minor packet loss is acceptable.


What is an HTTP request and how does it work?:


An HTTP request is a message sent by a client (usually a web browser) to a server to request some resources, such as a webpage, image, or data from an API. It follows the Hypertext Transfer Protocol (HTTP), which is the foundation of data communication on the web.

How Does an HTTP Request Work?
Client Sends a Request:

The client (e.g., a browser, mobile app) sends an HTTP request to a server, specifying what resource it needs. This could be in the form of:
Retrieving a webpage.
Submitting form data.
Accessing an API endpoint.

Components of an HTTP Request:

Request Line: This includes:
HTTP method (e.g., GET, POST, PUT, DELETE) which tells the server what action to perform.

URL: The resource or endpoint the client is requesting.

HTTP version: Specifies the HTTP protocol version (e.g., HTTP/1.1 or HTTP/2).

Headers: Key-value pairs that provide metadata about the request, such as:

User-Agent: Information about the client making the request.

Host: The domain name of the server.
Content-Type: The format of any data being sent (e.g., JSON, HTML).
Authorization: Credentials for accessing protected resources.
Body (optional): Contains data that the client wants to send to the server, typically used in POST or PUT requests.

Example of an HTTP GET request:

GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0

Server Receives the Request:

The server processes the request based on the provided information.
It checks the method, the requested resource, and any headers or data sent by the client.

Server Sends a Response:

The server sends an HTTP response back to the client. This contains:

Status Code: Indicates the success or failure of the request (e.g., 200 OK, 404 Not Found, 500 Internal Server Error).
Response Headers: Provide additional metadata about the response (e.g., Content-Type, Content-Length).
Response Body: Contains the data or resource requested by the client, such as an HTML page, JSON data, or an image.

Client Processes the Response:

The client receives the server’s response and renders or processes the data. For instance:
A browser will render the HTML to display a webpage.
An app might use the JSON data to display or update its interface.

Types of HTTP Methods

GET: Requests a resource without modifying it (e.g., fetch a webpage).
POST: Sends data to the server, often used for form submissions or API requests.
PUT: Updates or creates a resource.
DELETE: Deletes a specified resource.
PATCH: Applies partial modifications to a resource.

Example of HTTP Communication:

Client makes a GET request:

GET /api/user/1 HTTP/1.1
Host: api.example.com

Server responds:

HTTP/1.1 200 OK
Content-Type: application/json
{
   "id": 1,
   "name": "John Doe"
}


Express Introduction:


What is Express and why should I care?:

Express is a minimal and flexible web application framework for Node.js that is designed to simplify building web and mobile applications. It provides a robust set of features to develop APIs and web applications, allowing developers to manage different routes, handle HTTP requests, and work with middleware easily.

Why Should You Care About Express?

Simplifies Web Development: Express provides an abstraction over Node.js's built-in HTTP module, making it much easier to build web servers and manage routes.

Routing: Express makes routing easy by allowing developers to define multiple routes for handling different HTTP methods (GET, POST, PUT, DELETE). This helps organize code better, especially in larger applications.

Middleware Support: Express allows you to use middleware, which are functions executed in the request-response cycle. You can handle requests, modify responses, or add functionality, such as authentication or logging.

Asynchronous Handling: Built on top of Node.js, Express inherits its non-blocking, event-driven architecture, enabling better performance, especially for I/O-heavy applications like APIs or real-time data services.

Scalability: With its modular design, Express supports building scalable applications by allowing developers to break down an app into smaller, more manageable pieces.

Supports REST APIs: If you're working with RESTful APIs, Express is a go-to choice because of its simplicity in handling routes, request methods, and JSON data.

Strong Community and Ecosystem: Express has a large community with numerous plugins and middleware available for things like authentication, logging, data validation, etc.

Compatibility with Full-Stack JavaScript: Express is often used with popular front-end frameworks like React, Angular, or Vue and databases like MongoDB, creating a full-stack JavaScript environment known as the MEAN/MERN stack (MongoDB, Express, Angular/React, Node.js).

Use Cases:

Building APIs for mobile or web applications.
Creating lightweight web servers.
Developing real-time apps like chat systems.
Working on the backend for Single Page Applications (SPA).


Enter Express the basics:


Express is a fast, minimal, and flexible web application framework for Node.js, designed for building web applications and APIs. It simplifies server-side code by providing a set of robust features that help in managing HTTP requests, handling routes, and rendering views. Here are the basics of Express:

1. Installation
You need to have Node.js installed. Express can be installed using npm (Node Package Manager):

npm install express

2. Creating a Simple Express Server

To create a basic Express server:

const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});

app.get('/'): This is a route handler for the root path (/). It listens for GET requests and sends a "Hello, World!" response.
app.listen(3000): This starts the server on port 3000 and listens for incoming requests.

3. Routing

Routing refers to how an application responds to a client request to a particular endpoint. In Express, you can define routes using methods like app.get(), app.post(), app.put(), app.delete(), etc.

app.get('/about', (req, res) => {
  res.send('About page');
});

app.post('/submit', (req, res) => {
  res.send('Form submitted');
});

4. Middleware

Middleware functions in Express are functions that execute during the lifecycle of a request to the server. They can modify the request and response objects, end the request-response cycle, or call the next middleware function in the stack.

Example of using middleware:

app.use((req, res, next) => {
  console.log('Time:', Date.now());
  next();
});

5. Serving Static Files

Express can serve static files (like images, CSS files, and JavaScript files) using the express.static middleware.

app.use(express.static('public'));

This will serve files in the public directory.

6. Handling JSON and Form Data

Express comes with middleware to handle JSON and URL-encoded form data.

app.use(express.json()); // To parse JSON data
app.use(express.urlencoded({ extended: true })); // To parse form data

7. Error Handling

Error handling in Express is done using middleware with four arguments: err, req, res, next.

javascript
Copy code
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something went wrong!');
});

8. Template Engines

Express supports various template engines to generate HTML dynamically. You can set up a template engine like EJS or Pug.

javascript
Copy code
app.set('view engine', 'ejs');

app.get('/profile', (req, res) => {
  res.render('profile', { name: 'John Doe' });
});


Basic Routing in Express:


Routing in Express is how the server defines endpoints and the actions that will occur when a specific HTTP request hits the server. An endpoint typically consists of a route (path) and a method (GET, POST, etc.), and the route handler specifies what to do when a request is received.

Basic Setup

To start, you need to install Express:

npm install express

Next, let's set up an Express server in index.js:

const express = require('express');
const app = express();
const port = 3000;

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});

Basic Routing Example

Routes in Express are defined using methods like app.get(), app.post(), app.put(), app.delete(), and others. Let's go through each one with examples.

1. GET Route

The GET method is used to retrieve data. Below is an example of a simple GET route:

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

In this example, if the user accesses http://localhost:3000/, they will receive a response of "Hello, World!".

2. POST Route
The POST method is used to send data to the server (usually for creating or updating data).

app.post('/submit', (req, res) => {
  res.send('Form submitted');
});

When a POST request is made to /submit, the server will respond with "Form submitted".

3. PUT Route
The PUT method is typically used to update existing data.

app.put('/update', (req, res) => {
  res.send('Data updated');
});

This route will respond to a PUT request at /update.

4. DELETE Route

The DELETE method is used to remove data.

app.delete('/delete', (req, res) => {
  res.send('Data deleted');
});

Accessing this route will remove the data and send back the response "Data deleted".

Route Parameters

You can create dynamic routes with parameters. A route parameter is part of the URL and is defined by a :.

Example with Route Parameters:

app.get('/user/:id', (req, res) => {
  const userId = req.params.id;
  res.send(`User ID is ${userId}`);
});
When accessing http://localhost:3000/user/123, the response will be "User ID is 123". The req.params.id holds the value from the URL.

Query Parameters:

Express also supports query strings, which are passed in the URL after a ?.

Example with Query Parameters:

app.get('/search', (req, res) => {
  const searchTerm = req.query.term;
  res.send(`Search term is ${searchTerm}`);
});

Accessing http://localhost:3000/search?term=express will respond with "Search term is express". The 
req.query.term retrieves the value of term from the query string.

Route with Multiple Methods

Sometimes, the same route can respond to different HTTP methods:

app.route('/product')
  .get((req, res) => {
    res.send('Get a product');
  })
  .post((req, res) => {
    res.send('Add a product');
  })
  .put((req, res) => {
    res.send('Update the product');
  });

Here, the /product route handles GET, POST, and PUT requests.

Middleware in Routing

Middleware functions can be used to execute code before the request handler. This is useful for tasks like logging, authentication, and request validation.

const loggerMiddleware = (req, res, next) => {
  console.log(`Request made to: ${req.url}`);
  next(); // Call next() to pass control to the next middleware
};

app.use(loggerMiddleware);

app.get('/about', (req, res) => {
  res.send('About page');
});

In this example, the middleware logs each request before handling it.

Route Grouping

For cleaner code, you can group routes that share common logic using express.Router().

const router = express.Router();

router.get('/login', (req, res) => {
  res.send('Login page');
});

router.get('/signup', (req, res) => {
  res.send('Signup page');
});

app.use('/auth', router);

Now, /auth/login and /auth/signup will respond with the respective messages.

Conclusion

Express routing is powerful yet simple. You can define routes for different HTTP methods, use route parameters, query parameters, and middleware. This modular approach makes it easy to scale and organize your application as it grows.

Full Example Code

const express = require('express');
const app = express();
const port = 3000;

// Middleware
app.use((req, res, next) => {
  console.log(`Request Type: ${req.method}, URL: ${req.url}`);
  next();
});

// Basic Routes
app.get('/', (req, res) => res.send('Hello, World!'));
app.post('/submit', (req, res) => res.send('Form submitted'));
app.put('/update', (req, res) => res.send('Data updated'));
app.delete('/delete', (req, res) => res.send('Data deleted'));

// Route with parameters
app.get('/user/:id', (req, res) => {
  res.send(`User ID is ${req.params.id}`);
});

// Route with query parameters
app.get('/search', (req, res) => {
  res.send(`Search term is ${req.query.term}`);
});

// Grouped Routes using Router
const router = express.Router();
router.get('/login', (req, res) => res.send('Login page'));
router.get('/signup', (req, res) => res.send('Signup page'));
app.use('/auth', router);

// Start the server
app.listen(port, () => console.log(`Server running on port ${port}`));


Serving Static Files in Express:


In Express, serving static files like HTML, CSS, JavaScript, images, and other resources is a common task when building web applications. Static files are typically located in a publicly accessible directory and are sent directly to the client without server-side processing.

How to Serve Static Files in Express:
Step 1: Set up an Express app First, install Express if you haven't done so:

npm install express

Then, create a basic Express app in a file, say app.js:

const express = require('express');
const app = express();
const path = require('path');

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});

Step 2: Use express.static Middleware

Express provides a built-in middleware called express.static that you use to serve static files. You specify the directory where your static files are located, and Express will automatically serve the files when requested.

Here’s how to set it up:

const express = require('express');
const path = require('path');
const app = express();

// Serve static files from the "public" directory
app.use(express.static('public'));

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

In this example, any file placed in the public directory will be served by the server. For example, if 
you have a file public/index.html, it can be accessed via http://localhost:3000/index.html.

Examples of Serving Static Files

Basic Example: Serve an HTML file along with CSS and JavaScript.

Suppose you have the following structure:

project-folder/
├── app.js
└── public/
    ├── index.html
    ├── styles.css
    └── script.js
index.html:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <title>Static Files in Express</title>
</head>
<body>
  <h1>Hello World!</h1>
  <script src="script.js"></script>
</body>
</html>

styles.css:

body {
  background-color: #f0f0f0;
  font-family: Arial, sans-serif;
}

script.js:

console.log('JavaScript file loaded!');

When you start the server and go to http://localhost:3000/, the index.html will load, and it will link to the styles.css and script.js files automatically.

Serving Files from a Custom Directory

You can change the folder where static files are served by using path.join to specify a custom directory:

const express = require('express');
const path = require('path');
const app = express();

// Serve static files from the "assets" directory
app.use('/static', express.static(path.join(__dirname, 'assets')));

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

Suppose the file structure is:

project-folder/
├── app.js
└── assets/
    ├── images/
    │   └── logo.png
    └── css/
        └── main.css
Now, the files will be available at:

http://localhost:3000/static/images/logo.png
http://localhost:3000/static/css/main.css

Multiple Static Directories

You can serve files from multiple static directories using multiple express.static middleware calls:

app.use(express.static('public'));
app.use(express.static('assets'));

If the same file exists in both directories, Express will serve the file from the first static directory (in this case, public).

Serving Static Files with a Virtual Path Prefix

You can also set up a virtual path prefix for serving static files. This is useful if you want all static files to appear under a specific URL prefix without affecting the actual file path.

app.use('/static', express.static('public'));

Now, if you have public/logo.png, it will be accessible via http://localhost:3000/static/logo.png instead of just /logo.png.

Serving Static Files for Specific Routes

If you want to serve static files only for certain routes, you can combine route handlers with express.static:

app.use('/admin', express.static(path.join(__dirname, 'admin-assets')));

In this case, files in the admin-assets directory will only be served when requested from URLs that start with /admin. For example, admin-assets/admin.css will be served at http://localhost:3000/admin/admin.css.

Error Handling for Static Files

If the requested file doesn’t exist, Express will automatically return a 404 response. However, you can provide custom error handling:

app.use((req, res, next) => {
  res.status(404).send('Sorry, file not found!');
});

Summary

Basic static file serving: Use express.static() to serve files from a directory.
Custom directories: You can serve files from any directory by specifying the path.
Virtual path prefixes: Prefix static file URLs without changing the file system.
Multiple static directories: Serve files from multiple directories by using multiple express.static() calls.


